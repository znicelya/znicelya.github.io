[{"id":"236ba5ae8006493ed116e0eed1caa2a1","title":"定时任务备份Docker中的MySQL数据库","content":"定时任务备份Docker中的MySQL备份\n\n\n\n\n\n\n\n\n首先写一个备份docker中mysql的shell脚本\n#!&#x2F;bin&#x2F;bash\n# 备份路径\nBACKUP&#x3D;&#x2F;data&#x2F;backup&#x2F;db\n# 当前时间作为文件名\nDATETIME&#x3D;$(date +%Y%m%d_%H%M%S)\necho &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;开始备份&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;\necho &quot;备份路径是$BACKUP&#x2F;$DATETIME.tar.gz&quot;\n\n# 主机\nHOST&#x3D;loalhost\n#用户名\nDB_USER&#x3D;root\n#密码\nDB_PASS&#x3D;000000\n#数据库名\nDATABASE&#x3D;my_blog_db\n\nmkdir -p $BACKUP&#x2F;\n\ncd $BACKUP&#x2F;\n\necho &quot;start backup database sql files to localhost&quot;\n\t\t#mysql为镜像服务名\ndocker exec mysql mysqldump  -u$DB_USER -p$DB_PASS --databases $DATABASE &gt; $BACKUP&#x2F;$DATETIME.sql\n\ncd $BACKUP&#x2F;\n\ntar czf $DATETIME.tar.gz $DATETIME.sql\n\nrm -rf $DATETIME.sql\n\necho &quot;backup database sql files to localhost successfully&quot;\n然后\nchmod +x mysql-backup.sh\n为其加上执行权限\n我这里脚本文件名称为 mysql-backup.sh\n\n\n\n\n\n\n\n\n\n测试\nsh .&#x2F;mysql-backup.sh\n执行完毕之后发现目录下多了一个以日期为命名的压缩包\n解压查看无误\n定时\n\n\n\n\n\n\n\n\ncron\n首先确认cron是否开启\nsystemctl status cron\n\n如图所示为开启状态\n\n\n\n\n\n\n\n\n\ncrontab\ncrontab参数的使用\n\ncrontab -u：指定用户进行操作，如crontab -u lile -e 那么编辑的就是lile用户的crontab文件\ncrontab -l：输出当前crontab添加的定时任务\ncrontab -r：删除定时任务（慎用，或者做备份，删除就没了，存放的文件位置为/var/spool/cron目录下，以所属者命名）\ncrontab -e：编辑，添加定时任务\ncrontab -i：与-r参数一起使用，crontab -ri 的话会询问是否删除\n\n我们使用crontab来添加一条定时任务\ncrontab -e\n这时候会让我们选择以哪种方式编辑 选最熟悉的就好我这里选了Vim\n\n这条命令前面的两个0 第一个代表分 ， 第二个代表时\n至此mysql定时备份就完成了！\n","slug":"定时任务备份Docker中MYSQL数据库","date":"2022-02-11T09:22:11.000Z","categories_index":"Docker","tags_index":"Docker","author_index":"znicelya"},{"id":"8921f219ac1cdcf63bd94ba3e8d2edd1","title":"Docker安装Nginx","content":"Docker安装Niginx搜索镜像docker serach nginx\n\n\n拉取镜像拉取最新镜像\ndocker pull nginx:latest\n\n查看镜像docker image ls\n\n运行nginxdocker run nginx -d -p 80:80 nginx\n这时候我们已经可以访问到 nginx 的首页了但是如果我们需要配置nginx则比较麻烦 需要：\ndocker exec -it nginx bash\n在镜像里面配置\n挂载宿主机配置删除刚才启动的nginx镜像重新启动并挂载宿主机目录\ndocker run --name nginx -d \\\n\t--restart&#x3D;always \\\n\t--privileged&#x3D;true \\\n\t-v &#x2F;data&#x2F;env&#x2F;docker&#x2F;nginx&#x2F;html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html \\\n\t-v &#x2F;data&#x2F;env&#x2F;docker&#x2F;nginx&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf \\\n\t-v &#x2F;data&#x2F;env&#x2F;docker&#x2F;nginx&#x2F;conf&#x2F;conf.d&#x2F;default.conf:&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf \\\n\t-v &#x2F;data&#x2F;env&#x2F;docker&#x2F;nginx&#x2F;log:&#x2F;var&#x2F;log&#x2F;nginx \\\n\t-v &#x2F;data&#x2F;env&#x2F;docker&#x2F;nginx&#x2F;ssl:&#x2F;ssl&#x2F; \\\n\t-p 443:443 -p 80:80 \\\nnginx\n这样在我们的宿主机修改配置即可！\n","slug":"Docker安装Nginx","date":"2022-02-11T09:22:11.000Z","categories_index":"Docker","tags_index":"Docker","author_index":"znicelya"},{"id":"78ea6115ab3f3fc8e8054f26239972ae","title":"Mybatis配置详解","content":"Mybatis配置详解\n\n\n\n\n\n\n\n\nMyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。\n注意：这些配置的上下顺序必须严格按照约定顺序来，否则就会报错\n\nconfiguration\n\nproperties(属性)\nsetting(设置)\ntypeAliases(别名)\nplugins(插件)\nenvironments(环境配置)\nenvironment（环境变量）\ntransactionManager（事务管理器）\ndataSource（数据源）\n\n\n\n\nmapper(映射器)\n\n虽然官网上面的配置不止这些\n但以上的配置足以解决我们日常开发中的绝大部分问题\n\n\n1.1属性&lt;properties resource&#x3D;&quot;org&#x2F;mybatis&#x2F;example&#x2F;config.properties&quot;&gt;&lt;&#x2F;properties&gt;\n\n我们可以使用properties标签配置来引入资源文件\n同时我们可以使用property属性来替换外部引入的资源文件的内容\n就像下面这样\n&lt;properties resource&#x3D;&quot;org&#x2F;mybatis&#x2F;example&#x2F;config.properties&quot;&gt;\n  &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;dev_user&quot;&#x2F;&gt;\n  &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;F2Fa3!33TYyg&quot;&#x2F;&gt;\n&lt;&#x2F;properties&gt;\n\n当我们引入外部资源文件之后我们的配置就可以写在配置文件里面而不需要全部写在我们的xml配置里面\n可以减少代码的冗余，方便复用\n就行我上一篇写的数据源那里\n我们可以直接使用  ${} 来获取外部配置文件里面的配置\n如下\n&lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;\n  &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;$&#123;driver&#125;&quot;&#x2F;&gt;\n  &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;url&#125;&quot;&#x2F;&gt;\n  &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;username&#125;&quot;&#x2F;&gt;\n  &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;password&#125;&quot;&#x2F;&gt;\n&lt;&#x2F;dataSource&gt;\n\n注意：我们的配置文件可以在多个地方进行配置\n注意不要造成配置文件里面的属性被覆盖\n外部配置文件读取顺序为：\n\n首先读取在 properties 元素体内指定的属性。\n然后根据 properties 元素中的 resource 属性读取类路径下属性文件，或根据 url 属性指定的路径读取属性文件，并覆盖之前读取过的同名属性。\n最后读取作为方法参数传递的属性，并覆盖之前读取过的同名属性。\n\n从 MyBatis 3.4.2 开始，我们可以为占位符指定一个默认值，这样如果外部配置文件少写某个属性也不会报错\n比如：\n&lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;\n  &lt;!-- ... --&gt;\n  &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;username:ut_user&#125;&quot;&#x2F;&gt; \n    &lt;!-- 如果属性 &#39;username&#39; 没有被配置，&#39;username&#39; 属性的值将为 &#39;ut_user&#39; --&gt;\n&lt;&#x2F;dataSource&gt;\n\n但是这个特性默认是关闭的，我们需要手动开启\n&lt;properties resource&#x3D;&quot;org&#x2F;mybatis&#x2F;example&#x2F;config.properties&quot;&gt;\n  &lt;!-- ... --&gt;\n  &lt;property name&#x3D;&quot;org.apache.ibatis.parsing.PropertyParser.enable-default-value&quot; value&#x3D;&quot;true&quot;&#x2F;&gt; \n    &lt;!-- 启用默认值特性 --&gt;\n&lt;&#x2F;properties&gt;\n\n2.2设置 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。\n我们使用时用到的可以说并不多\n\n\n\n设置名\n描述\n有效值\n默认值\n\n\n\ncacheEnabled\n是否开启缓存\ntrue       false\ntrue\n\n\nlogImpl\n指定 MyBatis 所用日志的具体实现，未指定时将自动查找。\nSLF4J  LOG4J  LOG4J2  JDK_LOGGING  COMMONS_LOGGING  STDOUT_LOGGING  NO_LOGGING\n未设置\n\n\n平时使用中我们用的最多的就是日志了\n其他稍做了解即可，到需要用时可以直接查询官方文档\n一个配置完整的 settings 元素的示例如下：\n&lt;settings&gt;\n  &lt;setting name&#x3D;&quot;cacheEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;\n  &lt;setting name&#x3D;&quot;lazyLoadingEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;\n  &lt;setting name&#x3D;&quot;multipleResultSetsEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;\n  &lt;setting name&#x3D;&quot;useColumnLabel&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;\n  &lt;setting name&#x3D;&quot;useGeneratedKeys&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;\n  &lt;setting name&#x3D;&quot;autoMappingBehavior&quot; value&#x3D;&quot;PARTIAL&quot;&#x2F;&gt;\n  &lt;setting name&#x3D;&quot;autoMappingUnknownColumnBehavior&quot; value&#x3D;&quot;WARNING&quot;&#x2F;&gt;\n  &lt;setting name&#x3D;&quot;defaultExecutorType&quot; value&#x3D;&quot;SIMPLE&quot;&#x2F;&gt;\n  &lt;setting name&#x3D;&quot;defaultStatementTimeout&quot; value&#x3D;&quot;25&quot;&#x2F;&gt;\n  &lt;setting name&#x3D;&quot;defaultFetchSize&quot; value&#x3D;&quot;100&quot;&#x2F;&gt;\n  &lt;setting name&#x3D;&quot;safeRowBoundsEnabled&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;\n  &lt;setting name&#x3D;&quot;mapUnderscoreToCamelCase&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;\n  &lt;setting name&#x3D;&quot;localCacheScope&quot; value&#x3D;&quot;SESSION&quot;&#x2F;&gt;\n  &lt;setting name&#x3D;&quot;jdbcTypeForNull&quot; value&#x3D;&quot;OTHER&quot;&#x2F;&gt;\n  &lt;setting name&#x3D;&quot;lazyLoadTriggerMethods&quot; value&#x3D;&quot;equals,clone,hashCode,toString&quot;&#x2F;&gt;\n&lt;&#x2F;settings&gt;\n\n2.3类型别名类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写\n比如：\n&lt;typeAliases&gt;\n  &lt;typeAlias alias&#x3D;&quot;Author&quot; type&#x3D;&quot;domain.blog.Author&quot;&#x2F;&gt;\n&lt;&#x2F;typeAliases&gt;\n\n当我们使用这样的配置时\n在任何我们需要使用到domain.blog.Author时我们都可以使用Author来代替\n我们也可以指定一个包\nmybatis会自动把我们指定的包下的所有Bean都生成一个别名\n&lt;typeAliases&gt;\n  &lt;package name&#x3D;&quot;domain.blog&quot;&#x2F;&gt;\n&lt;&#x2F;typeAliases&gt;\n\n当然我们也可以使用注解来把我们需要使用别名的类标注\n@Alias(&quot;author&quot;)\npublic class Author &#123;\n    ...\n&#125;\n\n这样我们就可以使用author来代替domain.blog.Author\nMybatis它自己也为我们定义了一些常用数据类型或者类的别名\n\n\n\n别名\n映射的类型\n\n\n\n_byte\nbyte\n\n\n_long\nlong\n\n\n_short\nshort\n\n\n_int\nint\n\n\n_integer\nint\n\n\n_double\ndouble\n\n\n_float\nfloat\n\n\n_boolean\nboolean\n\n\nstring\nString\n\n\nbyte\nByte\n\n\nlong\nLong\n\n\nshort\nShort\n\n\nint\nInteger\n\n\ninteger\nInteger\n\n\ndouble\nDouble\n\n\nfloat\nFloat\n\n\nboolean\nBoolean\n\n\ndate\nDate\n\n\ndecimal\nBigDecimal\n\n\nbigdecimal\nBigDecimal\n\n\nobject\nObject\n\n\nmap\nMap\n\n\nhashmap\nHashMap\n\n\nlist\nList\n\n\narraylist\nArrayList\n\n\ncollection\nCollection\n\n\niterator\nIterator\n\n\n2.4插件当我们在使用mybatis时有时候会遇到功能不够用的情况\n我们可以使用插件\n比如我在做分页时可以导入一个pagehelper的插件来帮助我完成分页\n例如：\n&lt;plugins&gt;\n    &lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt;\n    &lt;plugin interceptor&#x3D;&quot;com.github.pagehelper.PageInterceptor&quot;&gt;\n        &lt;property name&#x3D;&quot;param1&quot; value&#x3D;&quot;value1&quot;&#x2F;&gt;\n\t&lt;&#x2F;plugin&gt;\n&lt;&#x2F;plugins&gt;\n\n2.5环境配置MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中， 现实情况下有多种理由需要这么做。例如，开发、测试和生产环境需要有不同的配置；或者想在具有相同 Schema 的多个生产数据库中使用相同的 SQL 映射。还有许多类似的使用场景。\n不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。\n所以，如果你想连接两个数据库，就需要创建两个 SqlSessionFactory 实例，每个数据库对应一个。而如果是三个数据库，就需要三个实例，依此类推\nenvironments 元素定义了如何配置环境。\n&lt;environments default&#x3D;&quot;development&quot;&gt;\n  &lt;environment id&#x3D;&quot;development&quot;&gt;\n    &lt;transactionManager type&#x3D;&quot;JDBC&quot;&gt;\n      &lt;property name&#x3D;&quot;...&quot; value&#x3D;&quot;...&quot;&#x2F;&gt;\n    &lt;&#x2F;transactionManager&gt;\n    &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;\n      &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;$&#123;driver&#125;&quot;&#x2F;&gt;\n      &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;url&#125;&quot;&#x2F;&gt;\n      &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;username&#125;&quot;&#x2F;&gt;\n      &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;password&#125;&quot;&#x2F;&gt;\n    &lt;&#x2F;dataSource&gt;\n  &lt;&#x2F;environment&gt;\n&lt;&#x2F;environments&gt;\n\n注意一些关键点:\n\n默认使用的环境 ID（比如：default=”development”）。\n每个 environment 元素定义的环境 ID（比如：id=”development”）。\n事务管理器的配置（比如：type=”JDBC”）。\n数据源(连接池)的配置（比如：type=”POOLED”）。\n\n事务管理器\n在 MyBatis 中有两种类型的事务管理器（也就是 type=”[JDBC|MANAGED]”）\n通常情况下我们会使用JDBC，因为JDBC有事务提交和回滚\n而MANAGED则从不提交或者回滚\n数据源（dataSource）\ndataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。\n\n大多数 MyBatis 应用程序会按示例中的例子来配置数据源。虽然数据源配置是可选的，但如果要启用延迟加载特性，就必须配置数据源。\n\nMybatis有三种内建的数据源类型（也就是 type=”[UNPOOLED|POOLED|JNDI]”）\n\n\n\n\n\n\n\n\n\nUNPOOLED\n这个数据源的实现会每次请求时打开和关闭连接,会比较浪费服务器资源，对那些数据库连接可用性要求不高的简单应用程序来说，是一个很好的选择，性能比较依赖于数据库类型，这种类型的数据源需要以下配置：\n\ndriver –&gt;数据库驱动类名\nurl–&gt;数据库url地址\nusername–&gt;数据库登陆名\npassword–&gt;数据库登陆密码\ndefaultTransactionIsolationLevel –&gt; 默认的连接事务隔离级别。\ndefaultNetworkTimeout–&gt;数据库默认链接超时时间\ndriver.encoding=UTF8–&gt;设置数据库编码格式为UTF-8\n\n\n\n\n\n\n\n\n\n\nPOOLED\n这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。 这种处理方式很流行，能使并发 Web 应用快速响应请求。\n这种类型的数据源除了需要上面的配置之外还可以配置更多的属性\n详细可见官网\n\n\n\n\n\n\n\n\n\nJNDI\n这个数据源实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的数据源引用。这种数据源配置只需要两个属性\n\ninitial_context – 这个属性用来在 InitialContext 中寻找上下文（即，initialContext.lookup(initial_context)）。这是个可选属性，如果忽略，那么将会直接从 InitialContext 中寻找 data_source 属性。\ndata_source – 这是引用数据源实例位置的上下文路径。提供了 initial_context 配置时会在其返回的上下文中进行查找，没有提供时则直接在 InitialContext 中查找。\n\n2.6映射器 MyBatis 的行为已经由上述元素配置完了，我们现在就要来定义 SQL 映射语句了，我们需要告诉 MyBatis 到哪里去找到这些SQL语句。 在自动查找资源方面，Java 并没有提供一个很好的解决方案，所以最好的办法是直接告诉 MyBatis 到哪里去找映射文件\n&lt;!-- 使用相对于类路径的资源引用 --&gt;\n&lt;mappers&gt;\n  &lt;mapper resource&#x3D;&quot;org&#x2F;mybatis&#x2F;builder&#x2F;AuthorMapper.xml&quot;&#x2F;&gt;\n  &lt;mapper resource&#x3D;&quot;org&#x2F;mybatis&#x2F;builder&#x2F;BlogMapper.xml&quot;&#x2F;&gt;\n  &lt;mapper resource&#x3D;&quot;org&#x2F;mybatis&#x2F;builder&#x2F;PostMapper.xml&quot;&#x2F;&gt;\n&lt;&#x2F;mappers&gt;\n\n因为我的mapper.xml文件通常放在resources文件目录下\n所以使用这种注册方式比较多\n当然如果你把mapper.xml文件放入了src下的java目录下也可以使用这两种方式\n&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;\n&lt;mappers&gt;\n  &lt;mapper class&#x3D;&quot;org.mybatis.builder.AuthorMapper&quot;&#x2F;&gt;\n  &lt;mapper class&#x3D;&quot;org.mybatis.builder.BlogMapper&quot;&#x2F;&gt;\n  &lt;mapper class&#x3D;&quot;org.mybatis.builder.PostMapper&quot;&#x2F;&gt;\n&lt;&#x2F;mappers&gt;\n\n&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;\n&lt;mappers&gt;\n  &lt;package name&#x3D;&quot;org.mybatis.builder&quot;&#x2F;&gt;\n&lt;&#x2F;mappers&gt;\n\n注意：使用这两种方法必须把Mapper接口和Mapper.xml文件放在同一目录下\n","slug":"Mybatis配置详解","date":"2022-02-10T11:40:11.000Z","categories_index":"Mybatis","tags_index":"Mybatis","author_index":"znicelya"},{"id":"a9afe666d8181b7b8b74143880e7533b","title":"工厂方法模式","content":"\n\n\n\n\n\n\n\n\n沉淀、分享、成长，让自己和他人都能有所收获！\n前言好看的代码千篇一律，恶心的程序升职加薪。\n\n\n\n\n\n\n\n\n\n几乎是程序员就都知道或者了解设计模式，但大部分小伙伴写代码总是习惯于一把梭。无论多少业务逻辑就一个类几千行，这样的开发也可以归纳为三步；定义属性、创建方法、调用展示，Done！只不过开发一时爽，重构火葬场。\n\n\n\n\n\n\n\n\n\n好的代码不只为了完成现有功能，也会考虑后续扩展。在结构设计上松耦合易读易扩展，在领域实现上高内聚不对外暴漏实现细节不被外部干扰。而这就有点像家里三居(MVC)室、四居(DDD)室的装修，你不会允许几十万的房子把走线水管裸漏在外面，也不会允许把马桶放到厨房，炉灶安装到卫生间。\n开发环境\njdk1.8\nIDEA+Maven\n\n工厂方法模式介绍\n\n工厂方法模式，图片来自 refactoringguru.cn\n\n工厂模式又称工厂方法模式，是一种创建型设计模式，其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。\n这种设计模式也是 Java 开发中最常见的一种模式，它的主要意图是定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。\n简单说就是为了提供代码结构的扩展性，屏蔽每一个功能类中的具体实现逻辑。让外部可以更加简单的只是知道调用即可，同时，这也是去掉众多ifelse的方式。当然这可能也有一些缺点，比如需要实现的类非常多，如何去维护，怎样减低开发成本。但这些问题都可以在后续的设计模式结合使用中，逐步降低\nexampleif…else…直接上代码\nif (val &#x3D;&#x3D; 1)&#123;\n    A a &#x3D; new A();\n    a.setA(1);\n    &#x2F;&#x2F; do something\n    log.info(&quot;执行A操作:&#123;&#125;&quot;,a);\n&#125;else if (val &#x3D;&#x3D; 2)&#123;\n    B b &#x3D; new B();\n    b.setB(2);\n    b.setBStr(&quot;BBBB&quot;);\n    &#x2F;&#x2F; do something\n    log.info(&quot;执行B操作:&#123;&#125;&quot;,b);\n&#125;else if (val &#x3D;&#x3D; 3)&#123;\n    C c &#x3D; new C();\n    c.setC(true);\n    &#x2F;&#x2F; do something\n    log.info(&quot;执行C操作:&#123;&#125;&quot;,c);\n&#125;\n\n\n如上就是使用 ifelse 非常直接的实现出来业务需求的一坨代码，如果仅从业务角度看，研发如期甚至提前实现了功能。\n那这样的代码目前来看并不会有什么问题，但如果在经过几次的迭代和拓展，接手这段代码的研发将十分痛苦。重构成本高需要理清之前每一个接口的使用，测试回归验证时间长，需要全部验证一次。这也就是很多人并不愿意接手别人的代码，如果接手了又被压榨开发时间。那么可想而知这样的 ifelse 还会继续增加。\n\nfactory接下来使用工厂方法模式来进行代码优化，也算是一次很小的重构。整理重构会你会发现代码结构清晰了、也具备了下次新增业务需求的扩展性。但在实际使用中还会对此进行完善，目前的只是抽离出最核心的部分体现到你面前，方便学习\n\n\n\n\n\n\n\n\n\n 定义接口\npublic interface IWord &#123;\n\n    void sayHello(int id, String name, Map&lt;String,Object&gt; extMap);\n\n&#125;\n\n\n\n\n\n\n\n\n\n\n实现接口\n@Slf4j\npublic class FactoryImpA implements IWord &#123;\n\n    @Override\n    public void sayHello(int id, String name, Map&lt;String, Object&gt; extMap) &#123;\n        log.info(&quot;id:&#123;&#125;,name:&#123;&#125;,map:&#123;&#125;&quot;,id,name,extMap);\n&#x2F;&#x2F;        Object something &#x3D; extMap.get(&quot;something&quot;);\n&#x2F;&#x2F;        something.doSomething\n    &#125;\n&#125;\n\n实现多个对应多个业务\n\n从上面可以看到每一种实现都包括在自己的类中，新增、修改或者删除都不会影响其他功能的测试，降低回归测试的可能。\n后续在新增的只需要按照此结构进行填充即可，非常易于维护和扩展。\n在统一了入参以及出参后，调用方不在需要关心内部逻辑，按照统一的方式即可处理\n\n\n\n\n\n\n\n\n\n\n创建工厂\npublic class WordFactory &#123;\n\n    public IWord getWordByVal(Integer val)&#123;\n        if (val &#x3D;&#x3D; null) return null;\n        if (val &#x3D;&#x3D; 1) return new FactoryImpA();\n&#x2F;&#x2F;        if (val &#x3D;&#x3D; 2) return .....\n        throw new RuntimeException(&quot;没有合适类型!&quot;);\n    &#125;\n&#125;\n\n\n\n这里我们定义了一个工厂类，在里面按照类型实现各种服务。可以非常干净整洁的处理你的代码，后续新增的在这里扩展即可。如果你不喜欢if判断，也可以使用switch或者map配置结构，会让代码更加干净。\n另外很多代码检查软件和编码要求，不喜欢if语句后面不写扩展，这里是为了更加干净的向你体现逻辑。在实际的业务编码中可以添加括号\n\n\n\n\n\n\n\n\n\n\n测试验证\nprivate void factoryTest(int val)&#123;\n    IWord wordByVal &#x3D; new WordFactory().getWordByVal(val);\n    wordByVal.sayHello(1,&quot;张三&quot;,new HashMap&lt;&gt;());\n&#125;\n\n\n\n总结\n从上到下的优化来看，工厂方法模式并不复杂，甚至这样的开发结构在你有所理解后，会发现更加简单了。\n那么这样的开发的好处知道后，也可以总结出来它的优点；避免创建者与具体的产品逻辑耦合、满足单一职责，每一个业务逻辑实现都在所属自己的类中完成、满足开闭原则，无需更改使用调用方就可以在程序中引入新的产品类型。但这样也会带来一些问题，比如有非常多的奖品类型，那么实现的子类会极速扩张。因此也需要使用其他的模式进行优化，这些在后续的设计模式中会逐步涉及到。\n从案例入手看设计模式往往要比看理论学的更加容易，因为案例是缩短理论到上手的最佳方式，如果你已经有所收获，一定要去尝试实操。\n\n","slug":"工厂方法模式","date":"2022-02-09T13:10:56.000Z","categories_index":"设计模式","tags_index":"工厂方法模式","author_index":"znicelya"},{"id":"08f5f5d9db8ab1e437781b3952ec2b51","title":"Mybatis基础入门","content":"1、Mybatis入门1.1导入依赖&lt;dependency&gt;\n    &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;3.5.6&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n导入依赖之后我们可以先按照官网所示先做一个小的demo\n1.2 编写配置文件\n第一步要使用Mybatis自然是需要Mybatis的配置文件了\n\n我们在src下的resources目录下新建一个Mybatis-config.xml文件\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE configuration\n  PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;\n  &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;\n&lt;configuration&gt;\n  \n&lt;&#x2F;configuration&gt;\n\nxml文件里面需要Mybatis的约束，从官网上拿下来就可以了\n大家都知道与数据库连接是需要一个Connection的，当然现在我们使用Mybatis仍然是需要的，\n当然在Mybatis里面它为我们做了封装\n我们只需要一个叫SqlSession的对象就可以了\n但是我们知道要连接数据库则是需要数据源的\n我们可以配置在上面的Mybatis-config.xml文件中\n&lt;environments default&#x3D;&quot;development&quot;&gt;\n        &lt;environment id&#x3D;&quot;development&quot;&gt;\n            &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt;\n            &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;\n                &lt;!--value&#x3D;&quot;$&#123;driver&#125;&quot;这种取值方式必须要读取properties文件--&gt;\n                &lt;!--我们可以通过在上面添加&lt;properties resource&#x3D;&quot;database.properties&quot;&#x2F;&gt;来读取properties文件--&gt;\n                &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;$&#123;driver&#125;&quot;&#x2F;&gt;\n                &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;url&#125;&quot;&#x2F;&gt;\n                &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;username&#125;&quot;&#x2F;&gt;\n                &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;password&#125;&quot;&#x2F;&gt;\n            &lt;&#x2F;dataSource&gt;\n        &lt;&#x2F;environment&gt;\n    &lt;&#x2F;environments&gt;\n\n这里也附上database.properties文件\ndriver&#x3D;com.mysql.jdbc.Driver\nurl&#x3D;jdbc:mysql:&#x2F;&#x2F;xxxx:3306&#x2F;mybatis?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8&amp;useSSL&#x3D;false\nusername&#x3D;root\npassword&#x3D;123456\n\n而我们需要知道的则是如何来拿到SqlSession对象并使用\n1.3编写MybatisUtils工具类\n如何拿到SqlSession并使用\n\n我们可以写一个工具类专门用于获取SqlSession对象\n首先我们通过看官网得知要使用SqlSession则必须有一个SqlSessionFactory对象来获取  \n通过看官网我们可以得知SqlSessionFactory对象则是由SqlSessionFactoryBuilder来获取的\nMybatisUtils文件放在下面\npublic class MyBatisUtils &#123;\n    private static SqlSessionFactory sqlSessionFactory;\n\n    static &#123;\n        InputStream inputStream &#x3D; null;\n        try &#123;\n            String resource &#x3D; &quot;Mybatis-config.xml&quot;;\n            inputStream &#x3D; Resources.getResourceAsStream(resource);\n            sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n\n    public static SqlSession getSqlSession()&#123;\n        return sqlSessionFactory.openSession();\n    &#125;\n&#125;\n\n到这里为止我们已经可以拿到数据库链接对象了\n下面我们实现一个小小的查询功能\n1.4实现查询功能首先我们遵循MVC三层架构模式\n建立以下几个包\n\n并提前把数据库字段映射成实体类（pojo）\n我们需要建一个mapper（dao）包，在mybatis项目中我习惯使用mapper\n然后在mapper包下面新建一个UserMapper接口\npublic interface UserMapper &#123;\n&#x2F;&#x2F;    获取所有用户\n    List&lt;User&gt; getUserList();\n&#125;\n\n\n按照我们以前的javaweb项目我们需要再建立一个UserMapper的实现类来实现它里面的方法\n而我们现在使用了Mybatis则不再需要实现类但我们需要一个UserMapper.xml来映射我们的UserMapper接口\n一般我们会把UserMapper.xml文件放在resources目录下\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;\n        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace&#x3D;&quot;fun.nicely.mapper.UserMapper&quot;&gt;\n\n    \n    \n&lt;&#x2F;mapper&gt;\n\n注意在这里我们一定要指明这个mapper文件映射的是哪个接口也就是：namespace 命名空间\n然后我们需要在这个mapper文件中写上SQL语句\n&lt;select id&#x3D;&quot;getUserList&quot; resultType&#x3D;&quot;fun.nicely.pojo.User&quot;&gt;\n        select * from user\n&lt;&#x2F;select&gt;\n\n注意id一定要和接口里面的方法名一样，mybatis就是通过id来映射的方法\n而resultType则是接口里面的方法要返回的数据类型\n最后\n最后我们要把UserMapper.xml文件注册到Mybatis-config.xml文件中\n我们在Mybatis-config.xml文件最后加上\n&lt;mappers&gt;\n        &lt;mapper resource&#x3D;&quot;UserMapper.xml&quot;&#x2F;&gt;\n&lt;&#x2F;mappers&gt;\n\n1.5测试我们写一个方法测试一下\n @Test\npublic void test() &#123;\n    SqlSession sqlSession &#x3D; null;\n    try &#123;\n        sqlSession &#x3D; MyBatisUtils.getSqlSession();\n        UserMapper mapper &#x3D; sqlSession.getMapper(UserMapper.class);\n        List&lt;User2&gt; userList &#x3D; mapper.getUserList();\n        for (User2 user : userList) &#123;\n            System.out.println(user);\n        &#125;\n    &#125;catch (Exception e)&#123;\n        e.printStackTrace();\n    &#125;finally &#123;\n        if (sqlSession !&#x3D; null) &#123;\n            sqlSession.close();\n        &#125;\n    &#125;\n&#125;\n\n测试结果\n","slug":"Mybatis基础入门","date":"2022-02-09T07:30:11.000Z","categories_index":"Mybatis","tags_index":"Mybatis","author_index":"znicelya"},{"id":"df024b531a7b1e89b5efdfbabc076190","title":"word文档转换","content":"word文档转换最近公司业务需求要把HTML和word文档互相转换，经过技术选型之后最终决定使用Apache POI（主要因为其他现有解决方案收费），记录一下\n\n\n\n\n\n\n\n\n\nMaven\n&lt;dependency&gt;\n    &lt;groupId&gt;org.htmlparser&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;htmlparser&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.6&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.poi&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;poi&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;4.0.1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.poi&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;poi-ooxml&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;4.0.1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;fr.opensagres.xdocreport&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;fr.opensagres.poi.xwpf.converter.core&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.0.2&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;fr.opensagres.xdocreport&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;fr.opensagres.poi.xwpf.converter.xhtml&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.0.2&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.poi&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;poi-scratchpad&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;4.0.1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\nHTML转DOCXHTML转换为docx需要借助htmlparser来解析html结构\n下面粘上代码\n&#x2F;&#x2F; 获取解析对象\nParser parser &#x3D; Parser.createParser(html, &quot;utf-8&quot;);\n&#x2F;&#x2F; 创建文档对象\nXWPFDocument document &#x3D; new XWPFDocument();\n&#x2F;&#x2F; 创建标签过滤器\nTagNameFilter pFilter &#x3D; new TagNameFilter(&quot;p&quot;);\n&#x2F;&#x2F; 解析 过滤器 得到节点列表\nNodeList nodeList &#x3D; parser.parse(pFilter);\n\n这样就拿到了所有的P标签（约定所有的元素都在P标签内）\n之后遍历所有的P元素向文档里面添加\nfor (int i &#x3D; 0; i &lt; nodeList.size(); i++) &#123;\n    &#x2F;&#x2F; 拿到普通 P 节点\n    ParagraphTag pNode &#x3D; (ParagraphTag) normalNodes.elementAt(i);\n    &#x2F;&#x2F; 建立word段落\n\tXWPFParagraph paragraph &#x3D; document.createParagraph();\n    &#x2F;&#x2F; 拿到P标签的所有子节点\n    NodeList pChildNodes &#x3D; pNode.getChildren();\n    if (pChildNodes !&#x3D; null) &#123;\n        &#x2F;&#x2F; 遍历P节点的子节点\n        for (int i1 &#x3D; 0; i1 &lt; pChildNodes.size(); i1++) &#123;\n            &#x2F;&#x2F; 创建 行\n            XWPFRun run &#x3D; paragraph.createRun();\n            Node node1 &#x3D; pChildNodes.elementAt(i1);\n            &#x2F;&#x2F; 文本节点\n            if (node1 instanceof TextNode)&#123;\n                if (StringUtils.isBlank(node1.toPlainTextString()))&#123;\n                    continue;\n                &#125;\n                run.setText(node1.toPlainTextString());\n                continue;\n            &#125;\n            &#x2F;&#x2F; 非文本 节点\n            TagNode spanNode &#x3D; (TagNode) pChildNodes.elementAt(i1);\n            &#x2F;&#x2F; 拿到 span style\n            String styleText &#x3D; spanNode.getAttribute(&quot;style&quot;);\n            &#x2F;&#x2F; ... 设置样式 ...\n            run &#x3D; paragraph.createRun();\n            &#x2F;&#x2F; 将 span节点内容写入 word\n            run.setText(spanNode.toPlainTextString());\n        &#125;\n    &#125;\n&#125;\n\n经过上面的操作就可以把一个简单的HTML文件转换为docx格式的word文档了\nps ： 注意这样只能解析固定格式的HTML，如果要解析复杂格式则需要递归进行控制\n这里贴上尾注操作方式\npublic static void addEndNote(XWPFDocument document, XWPFParagraph paragraph, String content, TagNode tagNode, ParagraphTag paragraphTag) &#123;\n    XWPFRun run &#x3D; paragraph.createRun();\n    CTFtnEdnRef fr &#x3D; run.getCTR().addNewEndnoteReference();\n    fr.setId(BigInteger.ONE);\n    document.createEndnotes();\n    CTFtnEdn ctNote &#x3D; CTFtnEdn.Factory.newInstance();\n    ctNote.setId(BigInteger.ONE);\n    ctNote.setType(STFtnEdn.NORMAL);\n    CTP ctp &#x3D; ctNote.addNewP();\n    XWPFParagraph p2 &#x3D; new XWPFParagraph(ctp, document);\n    run &#x3D; p2.createRun();\n    run.getCTR().addNewEndnoteRef();\n    CTText ctText &#x3D; run.getCTR().addNewT();\n    ctText.setStringValue(&quot; &quot;);\n    ctText.setSpace(SpaceAttribute.Space.PRESERVE);\n    run.setText(content);\n    htmlToDocX.setTextRunStyle(paragraph, run, tagNode, paragraphTag);\n    document.addEndnote(ctNote);\n&#125;\n\n脚注与尾注添加方式类似，只需稍作调整就可以\n目录实现可以参考\nApache POI自动生成Word文档（带目录）\nDOCX转HTMLDOCX转HTML则相对来说比较简单，POI内部对其做了实现\n&#x2F;&#x2F; 1) 加载word文档生成 XWPFDocument对象\nInputStream in &#x3D; new FileInputStream(word);\nXWPFDocument document &#x3D; new XWPFDocument(in);\nXHTMLOptions options &#x3D; XHTMLOptions.create();\noptions.setOmitHeaderFooterPages(true);\noptions.setIgnoreStylesIfUnused(false);\noptions.setFragment(true);\n&#x2F;&#x2F; base64 图片\noptions.setImageManager(new Base64EmbedImgManager());\n&#x2F;&#x2F; 也可以使用字符数组流获取解析的内容\nByteArrayOutputStream baos &#x3D; new ByteArrayOutputStream();\nXHTMLConverter.getInstance().convert(document, baos, options);\n&#x2F;&#x2F; HTML内容\nString content &#x3D; baos.toString();\nbaos.close();\nin.close();\n\nps: 这种方式有个缺陷就是尾注，脚注会丢失 需要自己手动去实现\n&#x2F;&#x2F; 获取所有尾注内容 及其索引\npublic static List&lt;Map&lt;Integer, String&gt;&gt; readEndNote(XWPFDocument document) throws Exception&#123;\n    List&lt;Map&lt;Integer,String&gt;&gt; maps &#x3D; new ArrayList&lt;&gt;();\n    List&lt;XWPFEndnote&gt; endnotes &#x3D; document.getEndnotes();\n    for (XWPFEndnote endnote : endnotes) &#123;\n        Map&lt;Integer,String&gt; map &#x3D; new HashMap&lt;&gt;();\n        Iterator&lt;XWPFParagraph&gt; iterator &#x3D; endnote.iterator();\n        while (iterator.hasNext()) &#123;\n            String text &#x3D; iterator.next().getText();\n            if (endnote.getId() !&#x3D; null &amp;&amp; StringUtils.isNotBlank(text))&#123;\n                map.put(endnote.getId().intValue(), text);\n                maps.add(map);\n            &#125;\n        &#125;\n    &#125;\n    return maps;\n&#125;\n\n上面拿到了文档的所有尾注\n但是我们没有办法去得到尾注应该出现的位置，最后详细阅读POI这一块的源码实现之后手动修改一部分使其支持转换\nXWPFDocumentVisitor.visitRun()\n&#x2F;&#x2F; 在这个方法里面添加\nList&lt;Map&lt;Integer, String&gt;&gt; maps &#x3D; readEndNote(run.getDocument());\nList&lt;CTFtnEdnRef&gt; endnoteReferenceList &#x3D; ctr.getEndnoteReferenceList();\nif (endnoteReferenceList.size() &gt; 0) &#123;\n    List&lt;XWPFEndnote&gt; endnotes &#x3D; run.getDocument().getEndnotes();\n    for (CTFtnEdnRef ctFtnEdnRef : endnoteReferenceList) &#123;\n        for (XWPFEndnote endnote : endnotes) &#123;\n            for (Map&lt;Integer, String&gt; map : maps) &#123;\n                for (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;\n                    if (map.get(endnote.getId().intValue()) !&#x3D; null\n                        &amp;&amp; endnote.getId().intValue() &#x3D;&#x3D; entry.getKey()\n                        &amp;&amp; ctFtnEdnRef.getId().intValue() &#x3D;&#x3D; endnote.getId().intValue()) &#123;\n                        &#x2F;&#x2F; Nicely定义 写出尾注\n                        &#x2F;&#x2F; 此方法需自己定义\n                        visitEndNote(entry.getValue());\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\nXHTMLMapper.class\n&#x2F;&#x2F; 此方法在XWPFDocumentVisitor定义 在XHTMLMapper中实现\npublic void visitEndNote(String content) throws Exception&#123;\n    AttributesImpl attributes &#x3D; new AttributesImpl();\n    &#x2F;&#x2F; 为其添加class\n    SAXHelper.addAttrValue(attributes, CLASS_ATTR, &quot;endNote&quot;);\n    &#x2F;&#x2F; 添加样式\n    SAXHelper.addAttrValue(attributes, STYLE_ATTR, &quot;color:red&quot;);\n    startElement(P_ELEMENT,attributes);\n    characters(StringEscapeUtils.escapeHtml(content));\n    endElement(P_ELEMENT);\n&#125;\n\n经过上面处理后大致为下图所示\n\n这时候需要用JS来控制其显示方式，将其放到尾部\n","slug":"word文档转换","date":"2022-02-05T09:22:11.000Z","categories_index":"poi","tags_index":"poi","author_index":"znicelya"},{"id":"95396110157e32674f9e9b0cbf309339","title":"给网站加上鼠标点击烟花效果","content":"给网站加上鼠标点击烟花效果\n\n\n\n\n\n\n\n\n效果如图\n\n\n\n\n\n\n\n\n\n\n具体实现\nclass Circle &#123;\n    constructor(&#123; origin, speed, color, angle, context &#125;) &#123;\n        this.origin &#x3D; origin\n        this.position &#x3D; &#123; ...this.origin &#125;\n        this.color &#x3D; color\n        this.speed &#x3D; speed\n        this.angle &#x3D; angle\n        this.context &#x3D; context\n        this.renderCount &#x3D; 0\n    &#125;\n\n    draw() &#123;\n        this.context.fillStyle &#x3D; this.color\n        this.context.beginPath()\n        this.context.arc(this.position.x, this.position.y, 2, 0, Math.PI * 2)\n        this.context.fill()\n    &#125;\n\n    move() &#123;\n        this.position.x &#x3D; (Math.sin(this.angle) * this.speed) + this.position.x\n        this.position.y &#x3D; (Math.cos(this.angle) * this.speed) + this.position.y + (this.renderCount * 0.3)\n        this.renderCount++\n    &#125;\n&#125;\n\nclass Boom &#123;\n    constructor (&#123; origin, context, circleCount &#x3D; 10, area &#125;) &#123;\n        this.origin &#x3D; origin\n        this.context &#x3D; context\n        this.circleCount &#x3D; circleCount\n        this.area &#x3D; area\n        this.stop &#x3D; false\n        this.circles &#x3D; []\n    &#125;\n\n    randomArray(range) &#123;\n        const length &#x3D; range.length\n        const randomIndex &#x3D; Math.floor(length * Math.random())\n        return range[randomIndex]\n    &#125;\n\n    randomColor() &#123;\n        const range &#x3D; [&#39;8&#39;, &#39;9&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;]\n        return &#39;#&#39; + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) + this.randomArray(range)\n    &#125;\n\n    randomRange(start, end) &#123;\n        return (end - start) * Math.random() + start\n    &#125;\n\n    init() &#123;\n        for(let i &#x3D; 0; i &lt; this.circleCount; i++) &#123;\n            const circle &#x3D; new Circle(&#123;\n                context: this.context,\n                origin: this.origin,\n                color: this.randomColor(),\n                angle: this.randomRange(Math.PI - 1, Math.PI + 1),\n                speed: this.randomRange(1, 6)\n            &#125;)\n            this.circles.push(circle)\n        &#125;\n    &#125;\n\n    move() &#123;\n        this.circles.forEach((circle, index) &#x3D;&gt; &#123;\n            if (circle.position.x &gt; this.area.width || circle.position.y &gt; this.area.height) &#123;\n                return this.circles.splice(index, 1)\n            &#125;\n            circle.move()\n        &#125;)\n        if (this.circles.length &#x3D;&#x3D; 0) &#123;\n            this.stop &#x3D; true\n        &#125;\n    &#125;\n\n    draw() &#123;\n        this.circles.forEach(circle &#x3D;&gt; circle.draw())\n    &#125;\n&#125;\n\nclass CursorSpecialEffects &#123;\n    constructor() &#123;\n        this.computerCanvas &#x3D; document.createElement(&#39;canvas&#39;)\n        this.renderCanvas &#x3D; document.createElement(&#39;canvas&#39;)\n\n        this.computerContext &#x3D; this.computerCanvas.getContext(&#39;2d&#39;)\n        this.renderContext &#x3D; this.renderCanvas.getContext(&#39;2d&#39;)\n\n        this.globalWidth &#x3D; window.innerWidth\n        this.globalHeight &#x3D; window.innerHeight\n\n        this.booms &#x3D; []\n        this.running &#x3D; false\n    &#125;\n\n    handleMouseDown(e) &#123;\n        const boom &#x3D; new Boom(&#123;\n            origin: &#123; x: e.clientX, y: e.clientY &#125;,\n            context: this.computerContext,\n            area: &#123;\n                width: this.globalWidth,\n                height: this.globalHeight\n            &#125;\n        &#125;)\n        boom.init()\n        this.booms.push(boom)\n        this.running || this.run()\n    &#125;\n\n    handlePageHide() &#123;\n        this.booms &#x3D; []\n        this.running &#x3D; false\n    &#125;\n\n    init() &#123;\n        const style &#x3D; this.renderCanvas.style\n        style.position &#x3D; &#39;fixed&#39;\n        style.top &#x3D; style.left &#x3D; 0\n        style.zIndex &#x3D; &#39;999999999999999999999999999999999999999999&#39;\n        style.pointerEvents &#x3D; &#39;none&#39;\n\n        style.width &#x3D; this.renderCanvas.width &#x3D; this.computerCanvas.width &#x3D; this.globalWidth\n        style.height &#x3D; this.renderCanvas.height &#x3D; this.computerCanvas.height &#x3D; this.globalHeight\n\n        document.body.append(this.renderCanvas)\n\n        window.addEventListener(&#39;mousedown&#39;, this.handleMouseDown.bind(this))\n        window.addEventListener(&#39;pagehide&#39;, this.handlePageHide.bind(this))\n    &#125;\n\n    run() &#123;\n        this.running &#x3D; true\n        if (this.booms.length &#x3D;&#x3D; 0) &#123;\n            return this.running &#x3D; false\n        &#125;\n\n        requestAnimationFrame(this.run.bind(this))\n\n        this.computerContext.clearRect(0, 0, this.globalWidth, this.globalHeight)\n        this.renderContext.clearRect(0, 0, this.globalWidth, this.globalHeight)\n\n        this.booms.forEach((boom, index) &#x3D;&gt; &#123;\n            if (boom.stop) &#123;\n                return this.booms.splice(index, 1)\n            &#125;\n            boom.move()\n            boom.draw()\n        &#125;)\n        this.renderContext.drawImage(this.computerCanvas, 0, 0, this.globalWidth, this.globalHeight)\n    &#125;\n&#125;\n\nconst cursorSpecialEffects &#x3D; new CursorSpecialEffects()\ncursorSpecialEffects.init()","slug":"给网站加上鼠标点击烟花效果","date":"2022-02-05T09:22:11.000Z","categories_index":"other","tags_index":"other","author_index":"znicelya"},{"id":"f4f86e9970dc96526d88d830c56237c7","title":"Docker 容器使用","content":"Docker 容器使用Docker 客户端docker 客户端非常简单 ,我们可以直接输入 docker 命令来查看到 Docker 客户端的所有命令选项。\nroot@VM-16-2-ubuntu:# docker\n\n可以通过命令 docker command –help 更深入的了解指定的 Docker 命令使用方法。\n例如我们要查看 docker stats 指令的具体使用方法：\nroot@VM-16-2-ubuntu:# docker stats --help\n\n容器使用获取镜像如果我们本地没有 ubuntu 镜像，我们可以使用 docker pull 命令来载入 ubuntu 镜像：\n$ docker pull ubuntu\n启动容器以下命令使用 ubuntu 镜像启动一个容器，参数为以命令行模式进入该容器：\n$ docker run -it ubuntu &#x2F;bin&#x2F;bash\n\n参数说明：\n\n-i: 交互式操作。\n-t: 终端。\nubuntu: ubuntu 镜像。\n/bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。\n\n要退出终端，直接输入 exit:\nroot@ed09e4490c57:&#x2F;# exit\n\n启动已停止运行的容器查看所有的容器命令如下：\n$ docker ps -a\n\n\n使用 docker start 启动一个已停止的容器：\n$ docker start b750bbbcfd88 \n\n后台运行在大部分的场景下，我们希望 docker 的服务是在后台运行的，我们可以过 -d 指定容器的运行模式。\n$ docker run -itd --name ubuntu-test ubuntu &#x2F;bin&#x2F;bash\n\n注：加了 -d 参数默认不会进入容器，想要进入容器需要使用指令 docker exec（下面会介绍到）。\n停止一个容器停止容器的命令如下：\n$ docker stop &lt;容器 ID&gt;\n\n停止的容器可以通过 docker restart 重启：\n$ docker restart &lt;容器 ID&gt;\n\n进入容器在使用 -d 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入：\n\ndocker attach\ndocker exec：推荐大家使用 docker exec 命令，因为此退出容器终端，不会导致容器的停止。\n\n\n\n\n\n\n\n\n\n\nattach 命令\n下面演示了使用 docker attach 命令。\n$ docker attach 1e560fca3906 \n\n注意： 如果从这个容器退出，会导致容器的停止。\n\n\n\n\n\n\n\n\n\nexec 命令\n下面演示了使用 docker exec 命令。\ndocker exec -it 243c32535da7 &#x2F;bin&#x2F;bash\n\n注意： 如果从这个容器退出，容器不会停止，这就是为什么推荐大家使用 docker exec 的原因。\n更多参数说明请使用 docker exec –help 命令查看。\n导出和导入容器导出容器如果要导出本地某个容器，可以使用 docker export 命令。\n$ docker export 1e560fca3906 &gt; ubuntu.tar\n导出容器 1e560fca3906 快照到本地文件 ubuntu.tar。\n\n这样将导出容器快照到本地文件。\n导入容器快照可以使用 docker import 从容器快照文件中再导入为镜像，以下实例将快照文件 ubuntu.tar 导入到镜像 test/ubuntu:v1:\n$ cat docker&#x2F;ubuntu.tar | docker import - test&#x2F;ubuntu:v1\n此外，也可以通过指定 URL 或者某个目录来导入，例如：\n$ docker import http:&#x2F;&#x2F;example.com&#x2F;exampleimage.tgz example&#x2F;imagerepo\n删除容器删除容器使用 docker rm 命令：\n$ docker rm -f 1e560fca3906\n\n下面的命令可以清理掉所有处于终止状态的容器。\n$ docker container prune","slug":"Docker容器使用","date":"2022-01-21T09:22:11.000Z","categories_index":"Docker","tags_index":"Docker","author_index":"znicelya"}]