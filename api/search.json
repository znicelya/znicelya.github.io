[{"id":"50d103871956e893966b30af3d9ba8af","title":"Hexo+Aurora+COS+CDN","content":"Hexo+Aurora+COS+CDNGit安装\n\n\n\n\n\n\n\n\nWindows\n访问官网\nhttps:&#x2F;&#x2F;git-scm.com&#x2F;\n\n\n直接安装即可\n若速度太慢可访问国内淘宝镜像\nhttps:&#x2F;&#x2F;registry.npmmirror.com&#x2F;binary.html?path&#x3D;git-for-windows&#x2F;\n\n\n\n\n\n\n\n\n\n\n\nLinux\n本人使用版本为Ubuntu 20.04教程以此版本为例\n\n首先确认系统是否已经安装Git\ngit\n\n\n出现上图则说明已安装Git可直接进入Hexo安装\n\n安装Git\napt install git\n测试\ngit --version\n\n\n\n配置\n\nuser.name\ngit config --global user.name &#x3D; &quot;git提交用户名称&quot;\nuser.email\ngit config --global user.email &#x3D; &quot;你的email&quot;\n\n\n\n 至此Git安装完成\nHexo是前端化工程，所以需要Node依赖\nNode.js安装\n\n\n\n\n\n\n\n\nWindows\n\n官网下载安装包\nhttps:&#x2F;&#x2F;nodejs.org&#x2F;zh-cn&#x2F;\n\n\n直接下一步、下一步安装即可\n\n\n\n\n\n\n\n\n\nLinux\n本人使用版本为Ubuntu 20.04教程以此版本为例\n\n更新apt源\napt update\n安装\n本教程发布时Node官网稳定版为16.14.0\ncurl -sL https:&#x2F;&#x2F;deb.nodesource.com&#x2F;setup_16.x | sudo -E bash -\n\n注意：如果你想安装其他版本只需在上面链接中修改 setup_16.x 为你想要的版本 例如：setup_12.x\n\n获取\nsudo apt-get install -y nodejs\n测试\n\n\n\nHexo安装1、官网https:&#x2F;&#x2F;hexo.io&#x2F;zh-cn&#x2F;\n\n\n2、安装npm install hexo-cli -g\n\n3、初始化在你的工作空间执行\nhexo init [项目名]\n\n我这里为hexoblog\n执行成功后进入目录\n\n目录结构与上图类似\n4、测试在此目录下执行\nhexo clean &amp; hexo g &amp; hexo s\n\n\nhexo clean：  清理编译文件\nhexo g：编译项目\nhexo s(server) : 本地预览运行项目\n\n\n访问http://localhost:4000即可看到\n\n访问结果如上图则为安装成功\nAurora安装\n1.安装进入hexo初始化目录执行\nnpm install hexo-theme-aurora --save\n\n\n2.配置2.1、创建配置文件因为主题是使用 NPM 或者 Yarn 安装的，而不是 clone 到 themes 文件夹的。所以我们需要自己创建一个配置文件。你只需要在 Hexo 博客的根目录下创建一个 _config.aurora.yml 配置文件来配置主题。\n\n此时打开配置文件发现是空的我们可以到node_modules下找到hexo-theme-aurora\n\n在此目录下我们发现有一个_config.aurora.yml文件，我们可以复制此文件到hexo初始化根目录下\n\n2.2、修改配置打开_config.yml\n\n\n\n\n\n\n\n\n\n修改路由方式\n由于aurora是Vue3项目，所以我们要修改路由为Aurora支持的方式\n\n找到URL下的permalink改为/post/:title.html\n\n\n\n\n\n\n\n\n\n修改代码高亮模式\naurora主题是使用 Prismjs 来实现代码高亮显示，但 Hexo 默认是使用 highlightjs，因此你需要更改 Hexo 配置来使用 Prismjs:\nhighlight:\n  enable: false\n  line_number: true\n  auto_detect: false\n  tab_replace: &#39;&#39;\n  wrap: true\n  hljs: false\nprismjs:\n  enable: true\n  preprocess: true\n  line_number: true\n  tab_replace: &#39;&#39;\n\n2.3、创建About页面主题默认开启了 about 页面，所以我们需要创建这个 about 页，要不主题就无法正常显示 about 页。\n要创建这个默认的 about 页，只需要执行这个 Hexo 的命令：\nhexo new page about\n\n执行完毕后，你会发现在 source/ 文件中多处了一个新的文件夹：\n.\n└── source\n    └── about\n        └── index.md\n\n你可以随意修改这个 index.md markdown 文件中的内容，此文件的内容将会现在在我们的 about 页面中。\n重新运行\nhexo clean &amp; hexo g &amp; hexo server\n\n\n此时aurora主题已安装完成\nCOS部署1.开通对象存储注册腾讯云账号并登录\n1.1 .搜索对象存储\n1.2.创建存储桶\n注意： 有些地区存储桶不支持CDN建议选择上海\n点击下一步\n\n这里不用选直接下一步\n\n点击创建即可\n1.3.开启静态网站\n2.部署Hexo到COS2.1.获取COS秘钥获取APPID，SecretId，SecretKey，Bucket，Region这五个参数\n\n新建秘钥\n\n2.2.安装博客推送插件hexo-deployer-cos-cdn\n到Hexo根目录下执行\nnpm install hexo-deployer-cos-cdn --save\n\n\n执行完成即可\n2.3.配置打开_config.yml文件\n配置deploy\n\ndeploy:\n  # tencent cos-cdn\n- type: cos-cdn\n  cloud: tencent\n  appId: 123456789 # 这里填写刚才新建立的秘钥的appid\n  secretId: abcdefghijklmnopqrstuvwxyz # 这里填写secretId\n  secretKey: abcdefghijklmnopqrstuvwxyz # 这里填写secretKey\n  bucket: hexo-blog-123456789 # 这里是存储桶名称\n  region: ap-shanghai # 这里是存储桶所属地区\n\n2.4. 编译推送执行\nhexo g -d\n\n结果\n\n注意：此操作会刷新CDN缓存 不必手动刷新\n2.5. 查看到存储桶里查看\n\n\n\n成功！\nCDN加速打开存储桶设置\n1.默认cdn加速\n源站类型选择 静态网站源站\n2.自定义域名加速2.1开启自定义域名加速\n2.2 域名解析\n记录值为cdn加速CNAME\n2.3 修改CDN刷新域名打开_config.yml\n\n教程结束！\n","slug":"Hexo-Aurora-Cos-CDN","date":"9999-12-31T15:59:59.000Z","categories_index":"Hexo,Aurora,Cos,CDN","tags_index":"hexo,aurora,cos,cdn","author_index":"zniceya"},{"id":"a8c22f633376d2280e1292f7c6481c88","title":"Curator客户端的使用","content":"Curator客户端的使用1.Curator介绍Curator是Netflix公司开源的一套zookeeper客户端框架，解决了很多Zookeeper客户端非常底层的细节开发工作，包括连接重连、反复注册Watcher和NodeExistsException异常等等。\n2.Curator引入&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.curator&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;curator-framework&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;5.1.0&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.curator&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;curator-recipes&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;5.1.0&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n3.Curator配置3.1 WrapperZKimport lombok.Data;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.stereotype.Component;\n\n&#x2F;**\n * TODO\n *\n * @author Nicely\n * @version 1.0\n * @since 2022&#x2F;2&#x2F;18 13:08\n *&#x2F;\n@Data\n@Component\n@ConfigurationProperties(prefix &#x3D; &quot;curator&quot;)\npublic class WrapperZK &#123;\n\n    private Integer retryCount;\n\n    private Integer elapsedTimeMs;\n\n    private String connectString;\n\n    private Integer sessionTimeoutMs;\n\n    private Integer connectionTimeoutMs;\n&#125;\n\n\n3.2 CuratorConfigimport org.apache.curator.framework.CuratorFramework;\nimport org.apache.curator.framework.CuratorFrameworkFactory;\nimport org.apache.curator.retry.RetryNTimes;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport javax.annotation.Resource;\n\n&#x2F;**\n * TODO\n *\n * @author Nicely\n * @version 1.0\n * @since 2022&#x2F;2&#x2F;18 13:13\n *&#x2F;\n@Configuration\npublic class CuratorConfig &#123;\n\n    @Resource\n    private WrapperZK wrapperZK;\n\n    @Bean(initMethod &#x3D; &quot;start&quot;)\n    public CuratorFramework curatorFramework()&#123;\n        return CuratorFrameworkFactory.newClient(\n                wrapperZK.getConnectString(),\n                wrapperZK.getSessionTimeoutMs(),\n                wrapperZK.getConnectionTimeoutMs(),\n                new RetryNTimes(wrapperZK.getRetryCount(),wrapperZK.getElapsedTimeMs())\n        );\n    &#125;\n&#125;\n\n\n4. Curator创建节点\n持久节点\nString path &#x3D; curatorFramework.create().forPath(&quot;&#x2F;curator-noe&#x2F;node1&quot;);\n持久序号节点\ncuratorFramework.create().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath(&quot;&#x2F;curator-noe&#x2F;node2&quot;, &quot;data&quot;.getBytes());\n临时节点\ncuratorFramework.create().withMode(CreateMode.EPHEMERAL).forPath(&quot;&#x2F;temp&quot;);\n临时序号节点\ncuratorFramework.create().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(&quot;&#x2F;temp&#x2F;tmpnode1&quot;);\n容器节点\ncuratorFramework.create().withMode(CreateMode.CONTAINER).forPath(&quot;&#x2F;container&quot;);\n多级节点\ncuratorFramework.create().creatingParentsIfNeeded().forPath(&quot;&#x2F;parent-node&#x2F;node-sub1&quot;);\n\n5. 获取节点内容byte[] bytes &#x3D; curatorFramework.getData().forPath(&quot;&#x2F;curator-noe&quot;);\nSystem.out.println(Arrays.toString(bytes));\n\n6.设置节点内容curatorFramework.setData().forPath(&quot;&#x2F;curator-noe&quot;, &quot;changed&quot;.getBytes());\nbyte[] bytes &#x3D; curatorFramework.getData().forPath(&quot;&#x2F;curator-noe&quot;);\nSystem.out.println(Arrays.toString(bytes));\n\n7. 删除节点curatorFramework.delete().guaranteed().deletingChildrenIfNeeded().forPath(&quot;&#x2F;parent-node&quot;);\n\n\n\n","slug":"zookeeper/Curator客户端的使用","date":"2022-02-18T04:20:21.000Z","categories_index":"zookeeper","tags_index":"zookeeper","author_index":"zniceya"},{"id":"0bdaded0df01ce59e401a378d6fd90c0","title":"Zookeeper客户端使用","content":"Zookeeper客户端使用1.多节点类型创建\n创建持久节点\ncreate [node]\n创建持久序号节点\ncreate -s [node]\n创建临时节点\ncreate -e [node]\n创建临时序号节点\ncreate -e -s [node]\n创建容器节点\ncreate -c [node]\n\n2.查询节点\n普通查询\nls &#x2F;\n递归查询\nls -R &#x2F;\n查询节点相关信息\nget -s &#x2F;test\n\n\ncZxid: 创建节点的事务ID\nmZxid: 修改节点的事务ID\npZxid: 查询和删除的事务ID\nctime: 节点创建的时间\nmtime: 节点修改的时间\ndataVersion: 节点内数据的版本，每更新一次数据，版本会+1\naclVersion: 此节点的权限版本\nephemeralOwner: 如果此节点是临时节点，该值是当前节点拥有者的session-id，如果节点不是临时节点，该值是0\ndataLength：节点内数据的长度\nnumChildren: 该节点的子节点的个数\n\n\n\n3.删除节点\n普通删除\ndelete [node]\n乐观锁删除\ndelete -v [version] [node]\n\n如果版本号不对则删除失败\n\n\n4.权限设置\n注册当前会话的账号和密码\nauth digest xiaoming:123456\n创建节点并设置权限\ncreate [node] [data] auth:user:password:cdwra\n\n\nnode : 节点\ndata : 数据\nuser：账号\npassword：密码\ncdwra\nc: 创建权限\nd: 删除权限\nw: 更新权限\nr: 读取权限\na: 管理员权限\n\n\n\n\n\n","slug":"zookeeper/Zookeeper客户端使用","date":"2022-02-16T14:09:21.000Z","categories_index":"zookeeper","tags_index":"zookeeper","author_index":"zniceya"},{"id":"17b79d7c2d3e679698db70e34f757a30","title":"IDEA报错\\UFEFF","content":"\n\n\n\n\n\n\n\n\nIDEA编译报错\\ufeff\n解决方法\n点击右下角编码改为GBK,点击Convert\n再把编码改回UTF-8，点击Convert\n\n如果新建文件之后还是出现这种情况请使用以下解决方法\n\n左上角点击 File-&gt;Settings-&gt;Editor-&gt;File Encodings\n把下面的Create UTF-8 files 改为 with NO BOM\n\n","slug":"IDEA报错ufeff","date":"2022-02-16T10:15:23.000Z","categories_index":"error","tags_index":"idea,error","author_index":"zniceya"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"Dubbo入门1.背景-网站应用的演进随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。\n\n单一应用架构当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。\n垂直应用架构当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，提升效率的方法之一是将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。\n分布式服务架构当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。\n流动计算架构当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。\n2.需求-Dubbo要解决的需求\n在大规模服务化之前，应用可能只是通过 RMI 或 Hessian 等工具，简单的暴露和引用远程服务，通过配置服务的URL地址进行调用，通过 F5 等硬件进行负载均衡。\n当服务越来越多时，服务 URL 配置管理变得非常困难，F5 硬件负载均衡器的单点压力也越来越大。 此时需要一个服务注册中心，动态地注册和发现服务，使服务的位置透明。并通过在消费方获取服务提供方地址列表，实现软负载均衡和 Failover，降低对 F5 硬件负载均衡器的依赖，也能减少部分成本。\n当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。 这时，需要自动画出应用间的依赖关系图，以帮助架构师理清关系。\n接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？ 为了解决这些问题，第一步，要将服务现在每天的调用量，响应时间，都统计出来，作为容量规划的参考指标。其次，要可以动态调整权重，在线上，将某台机器的权重一直加大，并在加大的过程中记录响应时间的变化，直到响应时间到达阈值，记录此时的访问量，再以此访问量乘以机器数反推总容量。\n以上是 Dubbo 最基本的几个需求。\n","slug":"Dubbo入门","date":"2022-02-14T13:05:44.271Z","categories_index":"","tags_index":"","author_index":"zniceya"},{"id":"05e68499718743acc72aacd2dcdacd5c","title":"Zookeeper数据结构","content":"Zookeeper数据结构2.1 名称空间zookkeeper 提供的名称空间非常类似于标准文件系统，key-value 的形式存储。名称 key 由斜线 / 分割的一系列路径元素，zookeeper 名称空间中的每个节点都是由一个路径标识。\n\n2.2 Zookeeper如何存储数据输入help查看zookeeper的帮助文档\n\n\n创建节点\ncreate [znode]\n创建节点并保存数据\ncreate [znode] [data]\n\n\n\n查看数据\nget [node]\n\n\n\n\n2.3 Zookeeper中的zndoe是什么样的数据结构zk中的znode中包含了四种数据\n\ndata\n保存数据\n\nacl\n权限：定义了什么样的用户能操作这个节点且能进行怎样的操作\n\nc : create 创建权限，允许在该节点下创建子节点\nw: write 更新权限，允许更新该节点下的数据\nr: read 读取权限，允许读取该节点及该节点下的子节点的列表信息\nd: delete 删除权限,允许删除该节点的子节点\na: admin 管理员权限,允许对该节点进行acl权限设置\n\n\nstat\n描述该节点的元数据\n\nchild\n当前节点的子节点\n\n\n2.4 ZK中节点的znode的类型\n持久节点：创建的节点在会话结束后依然存在。保存数据\n创建持久节点\ncreate [node]\n持久序号节点：创建出的节点，会根据先后顺序，在节点后跟上一个数值，越后执行数值越大，适用于分布式锁的应用场景-单调递增\n创建持久序号节点\ncreate -s [node]\n临时节点：\n创建临时节点\ncreate -e [node]\n\n临时节点是在会话结束后，自动被删除的(10s左右)，通过这个特性，zk可以实现服务注册与发现的效果，那么临时节点是如何维持心跳呢？\n\n\n临时序号节点 : 跟持久序号节点相同，适用于临时的分布式锁\n创建临时序号节点\ncreate -s -e [node]\nContainer节点(3.5.3版本新增): Container容器节点，当容器中没有任何节点，该容器节点会被zk定时删除(60s)\n\nTTL(Time To Life)节点：可以指定节点到期时间，到期后被zk定时删除\n通过系统配置zookeeper.extendedTypesEnable=true开启\n\n\n2.5 Zk的数据持久化zk的数据是运行在内存中的，zk提供了两种持久化机制\n\n事务日志\nzk把执行的命令以日志的形式保存在dataLogDir指定的文件夹中（如果没有dataLogDir则放入dataDir中）\n\n数据快照\nzk会在一定的时间间隔之内做一次内存数据的快照，把该时刻的内存中的数据保存在快照文件中\n\n\nzk通过两种形式的持久化，在恢复时先恢复快照中的数据到内存中，再用日志文件中的数据进行增量恢复，这样恢复的速度更快\n2.6 CAP理论CAP 理论指出对于一个分布式计算系统来说，不可能同时满足以下三点：\n\n一致性：在分布式环境中，一致性是指数据在多个副本之间是否能够保持一致的特性，等同于所有节点访问同一份最新的数据副本。在一致性的需求下，当一个系统在数据一致的状态下执行更新操作后，应该保证系统的数据仍然处于一致的状态。\n可用性：每次请求都能获取到正确的响应，但是不保证获取的数据为最新数据。\n分区容错性：分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。\n\n一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。\n在这三个基本需求中，最多只能同时满足其中的两项，P 是必须的，因此只能在 CP 和 AP 中选择，zookeeper 保证的是 CP，对比 spring cloud 系统中的注册中心 eruka 实现的是 AP。\n\n2.7 BASE 理论BASE 是 Basically Available(基本可用)、Soft-state(软状态) 和 Eventually Consistent(最终一致性) 三个短语的缩写。\n\n基本可用：在分布式系统出现故障，允许损失部分可用性（服务降级、页面降级）。\n软状态：允许分布式系统出现中间状态。而且中间状态不影响系统的可用性。这里的中间状态是指不同的 data replication（数据备份节点）之间的数据更新可以出现延时的最终一致性。\n最终一致性：data replications 经过一段时间达到一致性。\n\nBASE 理论是对 CAP 中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。\n","slug":"zookeeper/Zookeeper数据结构","date":"2022-02-14T04:41:21.000Z","categories_index":"zookeeper","tags_index":"zookeeper","author_index":"zniceya"},{"id":"07093428334d4e05f766e4aacfd1b9ce","title":"Zookeeper概述","content":"1. Zookeeper概述1.1 Zookeeper背景　　随着互联网技术的发展，企业对计算机系统的计算，存储能力要求越来越高，各大IT企业都在追求高并发，海量存储的极致，在这样的背景下，单纯依靠少量高性能单机来完成计算机，云计算的任务已经无法满足需求，企业的IT架构逐渐由集中式往分布式过渡。所谓的分布式是指：把一个计算任务分解成若干个计算单元，并分派到不同的计算机中去执行，最终汇总计算结果的过程。\n1.2 Zookeeper概述　　Zookeeper是源代码开放的分布式协调服务，是一个高性能的分布式数据一致性的解决方案，它将那些复杂的，容易出错的分布式一致性服务封装起来。用户可以通过调用Zookeeper提供的接口来解决一些分布式应用中的实际问题。\n1.3 Zookeeper典型应用场景\n数据发布/订阅\n\n　　数据的发布与订阅，顾名思义就是一方把数据发布出来，另一方通过某种手段获取。\n　　通常数据发布与订阅有两种模式：推模式和拉模式，推模式一般是服务器主动往客户端推送信息，拉模式是客户端主动去服务端请求目标数据（通常采用定时轮询的方式）\n　　Zookeeper采用两种方式互相结合：发布者将数据发布到Zookeeper集群节点上，订阅者通过一定的方法告诉Zookeeper服务器，自己对哪个节点的数据感兴趣，那么在服务端数据发生变化时，就会通知客户端去获取这些信息。\n\n负载均衡\n\n　　　　 \n　　首先在服务端启动的时候，把自己在zookeeper服务器上注册成一个临时节点。zookeeper拥有两种形式的节点，一种是临时节点，一种是永久节点。这两种节点后面的博客会有较为详细的介绍。注册成临时节点后，再服务端出问题时，节点会自动的从zookeeper上删除，如此zookeeper服务器上的列表就是最新的可用的列表。\n　　客户端在需要访问服务器的时候首先会去Zookeeper获得所有可用的服务端的连接信息。\n　　客户端通过一定的策略（如随机）选择一个与之建立连接。\n　　当客户端发现连接不可用时，会再次从zookeeper上获取可用的服务端连接，并同时删除之前获取的连接列表。\n\n命名服务\n\n　　提供名称的服务。如一般使用较多的有两种id，一种是数据库自增长id，一种是UUID，两种id都有局限，自增长id仅适合在单表单库中使用，uuid适合在分布式系统中使用但由于id没有规律难以理解。而ZK提供了一定的接口可以用来获取一个顺序增长的，可以在集群环境下使用的id。\n\n分布式协调，通知，心跳服务\n\n　　在分布式服务系统中，我们常常需要知道哪个服务是可用的，哪个服务是不可用的，传统的方式是通过ping主机来实现的，ping得200的结果说明说明该服务是OK的。\n　　而在使用 zookeeper时，可以将所有的服务都注册成一个临时节点，我们判断一个服务是否可用，只需要判断这个节点是否在zookeeper集群中存在就可以了，不需要直接去连接和ping服务所在主机，减少系统的复杂度和对服务主机的压力。\n1.4 Zookeeper优势\n源代码开放\n\n高性能，易用稳定，该优势已在众多分布式系统中得到验证\n\n有着广泛的应用，并且与众多大数据相关技术能实现良好的融合开发。\n\n\n1.5 Zookeeper特点\nZookeeper : 一个领导者 leader ，多个跟随者 follower 组成的集群\n集群只要有半数以上节点存活，Zookeeper集群就能正常工作。所以zookeeper集群适合安装奇数台服务器\n全局数据一致：每个server保存一份相同的数据副本，Client无论连接哪一台Server，数据都是一致的\n更新请求顺序执行，来自同一个Client的更新请求按其发送顺序执行\n数据更新原子性，一次更新要么成功，要么失败\n实时性，在一定时间范围内，Client能读到最新数据\n\n","slug":"zookeeper/Zookeeper概述","date":"2022-02-14T04:40:21.000Z","categories_index":"zookeeper","tags_index":"zookeeper","author_index":"zniceya"},{"id":"7466612641d081c2147b711ae5edcb46","title":"Zookeeper安装","content":"Zookeeper安装1. 单机安装1.1官网zookeeper 下载地址为: https://zookeeper.apache.org/releases.html\n\n选择一个稳定版本 我这里选择的是3.7.0\n\n1.2点击下载\n1.3解压\n建立数据存放目录 data 和日志存放目录 log\n1.4配置进入conf目录\n复制 zoo_sample.cfg 改名为 zoo.cfg\n编辑zoo.cfg\n\n1.5运行进入bin目录\nwindows系统下直接双击zkServer.cmd即可\nlinux系统下执行 ./zkServer.sh start\n\n至此单机版安装完成！\n2.集群搭建由于我这里只有一台机器只能搭建一个伪集群\n1.安装将刚才解压的zookeeper文件 复制两份\n\n分别修改其配置（同上） \n注意：端口不要重复\n2.配置\n端口配置\n\nzk1\n\n\n\n\nzk2\n\n\nzk3\n\n\n\n现在三个zk的端口分别是 2181、2182、2183\n注意： 此端口为客户端连接端口\n\nmyid配置\n三个zk需要各自的编号\n我们在上面指定的dataDir下创建myid文件                                            \n\n编辑每个myid文件\n在zk1的myid文件里面写入1\n在zk2的myid文件中写入2\n在zk3的myid文件中写入3\n\n配置集群连接\n查看宿主机ip\n\n编辑三个zoo.cfg文件\n在最后加入\n\nserver.1&#x3D;192.168.2.79:2881:3881\nserver.2&#x3D;192.168.2.79:2882:3882\nserver.3&#x3D;192.168.2.79:2883:3883\n\nPS\nserver.[myid]=[ip]:[集群数据同步端口]:[leader选举端口]\n\n\n伪集群搭建完毕！\n","slug":"zookeeper/Zookeeper安装","date":"2022-02-14T04:20:21.000Z","categories_index":"zookeeper","tags_index":"zookeeper","author_index":"zniceya"},{"id":"4b6f4220aabf9bab7576762495891640","title":"Bing-Dwen-Dwen","content":"\n","slug":"Bing-Dwen-Dwen","date":"2022-02-12T06:27:46.000Z","categories_index":"","tags_index":"冰墩墩","author_index":"zniceya"},{"id":"8921f219ac1cdcf63bd94ba3e8d2edd1","title":"Docker安装Nginx","content":"Docker安装Niginx搜索镜像docker serach nginx\n\n\n拉取镜像拉取最新镜像\ndocker pull nginx:latest\n\n查看镜像docker image ls\n\n运行nginxdocker run nginx -d -p 80:80 nginx\n这时候我们已经可以访问到 nginx 的首页了但是如果我们需要配置nginx则比较麻烦 需要：\ndocker exec -it nginx bash\n在镜像里面配置\n挂载宿主机配置删除刚才启动的nginx镜像重新启动并挂载宿主机目录\ndocker run --name nginx -d \\\n\t--restart&#x3D;always \\\n\t--privileged&#x3D;true \\\n\t-v &#x2F;data&#x2F;env&#x2F;docker&#x2F;nginx&#x2F;html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html \\\n\t-v &#x2F;data&#x2F;env&#x2F;docker&#x2F;nginx&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf \\\n\t-v &#x2F;data&#x2F;env&#x2F;docker&#x2F;nginx&#x2F;conf&#x2F;conf.d&#x2F;default.conf:&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf \\\n\t-v &#x2F;data&#x2F;env&#x2F;docker&#x2F;nginx&#x2F;log:&#x2F;var&#x2F;log&#x2F;nginx \\\n\t-v &#x2F;data&#x2F;env&#x2F;docker&#x2F;nginx&#x2F;ssl:&#x2F;ssl&#x2F; \\\n\t-p 443:443 -p 80:80 \\\nnginx\n这样在我们的宿主机修改配置即可！\n","slug":"Docker安装Nginx","date":"2022-02-11T09:22:11.000Z","categories_index":"Docker","tags_index":"Docker","author_index":"zniceya"},{"id":"78ea6115ab3f3fc8e8054f26239972ae","title":"Mybatis配置详解","content":"Mybatis配置详解\n\n\n\n\n\n\n\n\nMyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。\n注意：这些配置的上下顺序必须严格按照约定顺序来，否则就会报错\n\nconfiguration\n\nproperties(属性)\nsetting(设置)\ntypeAliases(别名)\nplugins(插件)\nenvironments(环境配置)\nenvironment（环境变量）\ntransactionManager（事务管理器）\ndataSource（数据源）\n\n\n\n\nmapper(映射器)\n\n虽然官网上面的配置不止这些\n但以上的配置足以解决我们日常开发中的绝大部分问题\n\n\n1.1属性&lt;properties resource&#x3D;&quot;org&#x2F;mybatis&#x2F;example&#x2F;config.properties&quot;&gt;&lt;&#x2F;properties&gt;\n\n我们可以使用properties标签配置来引入资源文件\n同时我们可以使用property属性来替换外部引入的资源文件的内容\n就像下面这样\n&lt;properties resource&#x3D;&quot;org&#x2F;mybatis&#x2F;example&#x2F;config.properties&quot;&gt;\n  &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;dev_user&quot;&#x2F;&gt;\n  &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;F2Fa3!33TYyg&quot;&#x2F;&gt;\n&lt;&#x2F;properties&gt;\n\n当我们引入外部资源文件之后我们的配置就可以写在配置文件里面而不需要全部写在我们的xml配置里面\n可以减少代码的冗余，方便复用\n就行我上一篇写的数据源那里\n我们可以直接使用  ${} 来获取外部配置文件里面的配置\n如下\n&lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;\n  &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;$&#123;driver&#125;&quot;&#x2F;&gt;\n  &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;url&#125;&quot;&#x2F;&gt;\n  &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;username&#125;&quot;&#x2F;&gt;\n  &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;password&#125;&quot;&#x2F;&gt;\n&lt;&#x2F;dataSource&gt;\n\n注意：我们的配置文件可以在多个地方进行配置\n注意不要造成配置文件里面的属性被覆盖\n外部配置文件读取顺序为：\n\n首先读取在 properties 元素体内指定的属性。\n然后根据 properties 元素中的 resource 属性读取类路径下属性文件，或根据 url 属性指定的路径读取属性文件，并覆盖之前读取过的同名属性。\n最后读取作为方法参数传递的属性，并覆盖之前读取过的同名属性。\n\n从 MyBatis 3.4.2 开始，我们可以为占位符指定一个默认值，这样如果外部配置文件少写某个属性也不会报错\n比如：\n&lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;\n  &lt;!-- ... --&gt;\n  &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;username:ut_user&#125;&quot;&#x2F;&gt; \n    &lt;!-- 如果属性 &#39;username&#39; 没有被配置，&#39;username&#39; 属性的值将为 &#39;ut_user&#39; --&gt;\n&lt;&#x2F;dataSource&gt;\n\n但是这个特性默认是关闭的，我们需要手动开启\n&lt;properties resource&#x3D;&quot;org&#x2F;mybatis&#x2F;example&#x2F;config.properties&quot;&gt;\n  &lt;!-- ... --&gt;\n  &lt;property name&#x3D;&quot;org.apache.ibatis.parsing.PropertyParser.enable-default-value&quot; value&#x3D;&quot;true&quot;&#x2F;&gt; \n    &lt;!-- 启用默认值特性 --&gt;\n&lt;&#x2F;properties&gt;\n\n2.2设置 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。\n我们使用时用到的可以说并不多\n\n\n\n设置名\n描述\n有效值\n默认值\n\n\n\ncacheEnabled\n是否开启缓存\ntrue       false\ntrue\n\n\nlogImpl\n指定 MyBatis 所用日志的具体实现，未指定时将自动查找。\nSLF4J  LOG4J  LOG4J2  JDK_LOGGING  COMMONS_LOGGING  STDOUT_LOGGING  NO_LOGGING\n未设置\n\n\n平时使用中我们用的最多的就是日志了\n其他稍做了解即可，到需要用时可以直接查询官方文档\n一个配置完整的 settings 元素的示例如下：\n&lt;settings&gt;\n  &lt;setting name&#x3D;&quot;cacheEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;\n  &lt;setting name&#x3D;&quot;lazyLoadingEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;\n  &lt;setting name&#x3D;&quot;multipleResultSetsEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;\n  &lt;setting name&#x3D;&quot;useColumnLabel&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;\n  &lt;setting name&#x3D;&quot;useGeneratedKeys&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;\n  &lt;setting name&#x3D;&quot;autoMappingBehavior&quot; value&#x3D;&quot;PARTIAL&quot;&#x2F;&gt;\n  &lt;setting name&#x3D;&quot;autoMappingUnknownColumnBehavior&quot; value&#x3D;&quot;WARNING&quot;&#x2F;&gt;\n  &lt;setting name&#x3D;&quot;defaultExecutorType&quot; value&#x3D;&quot;SIMPLE&quot;&#x2F;&gt;\n  &lt;setting name&#x3D;&quot;defaultStatementTimeout&quot; value&#x3D;&quot;25&quot;&#x2F;&gt;\n  &lt;setting name&#x3D;&quot;defaultFetchSize&quot; value&#x3D;&quot;100&quot;&#x2F;&gt;\n  &lt;setting name&#x3D;&quot;safeRowBoundsEnabled&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;\n  &lt;setting name&#x3D;&quot;mapUnderscoreToCamelCase&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;\n  &lt;setting name&#x3D;&quot;localCacheScope&quot; value&#x3D;&quot;SESSION&quot;&#x2F;&gt;\n  &lt;setting name&#x3D;&quot;jdbcTypeForNull&quot; value&#x3D;&quot;OTHER&quot;&#x2F;&gt;\n  &lt;setting name&#x3D;&quot;lazyLoadTriggerMethods&quot; value&#x3D;&quot;equals,clone,hashCode,toString&quot;&#x2F;&gt;\n&lt;&#x2F;settings&gt;\n\n2.3类型别名类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写\n比如：\n&lt;typeAliases&gt;\n  &lt;typeAlias alias&#x3D;&quot;Author&quot; type&#x3D;&quot;domain.blog.Author&quot;&#x2F;&gt;\n&lt;&#x2F;typeAliases&gt;\n\n当我们使用这样的配置时\n在任何我们需要使用到domain.blog.Author时我们都可以使用Author来代替\n我们也可以指定一个包\nmybatis会自动把我们指定的包下的所有Bean都生成一个别名\n&lt;typeAliases&gt;\n  &lt;package name&#x3D;&quot;domain.blog&quot;&#x2F;&gt;\n&lt;&#x2F;typeAliases&gt;\n\n当然我们也可以使用注解来把我们需要使用别名的类标注\n@Alias(&quot;author&quot;)\npublic class Author &#123;\n    ...\n&#125;\n\n这样我们就可以使用author来代替domain.blog.Author\nMybatis它自己也为我们定义了一些常用数据类型或者类的别名\n\n\n\n别名\n映射的类型\n\n\n\n_byte\nbyte\n\n\n_long\nlong\n\n\n_short\nshort\n\n\n_int\nint\n\n\n_integer\nint\n\n\n_double\ndouble\n\n\n_float\nfloat\n\n\n_boolean\nboolean\n\n\nstring\nString\n\n\nbyte\nByte\n\n\nlong\nLong\n\n\nshort\nShort\n\n\nint\nInteger\n\n\ninteger\nInteger\n\n\ndouble\nDouble\n\n\nfloat\nFloat\n\n\nboolean\nBoolean\n\n\ndate\nDate\n\n\ndecimal\nBigDecimal\n\n\nbigdecimal\nBigDecimal\n\n\nobject\nObject\n\n\nmap\nMap\n\n\nhashmap\nHashMap\n\n\nlist\nList\n\n\narraylist\nArrayList\n\n\ncollection\nCollection\n\n\niterator\nIterator\n\n\n2.4插件当我们在使用mybatis时有时候会遇到功能不够用的情况\n我们可以使用插件\n比如我在做分页时可以导入一个pagehelper的插件来帮助我完成分页\n例如：\n&lt;plugins&gt;\n    &lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt;\n    &lt;plugin interceptor&#x3D;&quot;com.github.pagehelper.PageInterceptor&quot;&gt;\n        &lt;property name&#x3D;&quot;param1&quot; value&#x3D;&quot;value1&quot;&#x2F;&gt;\n\t&lt;&#x2F;plugin&gt;\n&lt;&#x2F;plugins&gt;\n\n2.5环境配置MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中， 现实情况下有多种理由需要这么做。例如，开发、测试和生产环境需要有不同的配置；或者想在具有相同 Schema 的多个生产数据库中使用相同的 SQL 映射。还有许多类似的使用场景。\n不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。\n所以，如果你想连接两个数据库，就需要创建两个 SqlSessionFactory 实例，每个数据库对应一个。而如果是三个数据库，就需要三个实例，依此类推\nenvironments 元素定义了如何配置环境。\n&lt;environments default&#x3D;&quot;development&quot;&gt;\n  &lt;environment id&#x3D;&quot;development&quot;&gt;\n    &lt;transactionManager type&#x3D;&quot;JDBC&quot;&gt;\n      &lt;property name&#x3D;&quot;...&quot; value&#x3D;&quot;...&quot;&#x2F;&gt;\n    &lt;&#x2F;transactionManager&gt;\n    &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;\n      &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;$&#123;driver&#125;&quot;&#x2F;&gt;\n      &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;url&#125;&quot;&#x2F;&gt;\n      &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;username&#125;&quot;&#x2F;&gt;\n      &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;password&#125;&quot;&#x2F;&gt;\n    &lt;&#x2F;dataSource&gt;\n  &lt;&#x2F;environment&gt;\n&lt;&#x2F;environments&gt;\n\n注意一些关键点:\n\n默认使用的环境 ID（比如：default=”development”）。\n每个 environment 元素定义的环境 ID（比如：id=”development”）。\n事务管理器的配置（比如：type=”JDBC”）。\n数据源(连接池)的配置（比如：type=”POOLED”）。\n\n事务管理器\n在 MyBatis 中有两种类型的事务管理器（也就是 type=”[JDBC|MANAGED]”）\n通常情况下我们会使用JDBC，因为JDBC有事务提交和回滚\n而MANAGED则从不提交或者回滚\n数据源（dataSource）\ndataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。\n\n大多数 MyBatis 应用程序会按示例中的例子来配置数据源。虽然数据源配置是可选的，但如果要启用延迟加载特性，就必须配置数据源。\n\nMybatis有三种内建的数据源类型（也就是 type=”[UNPOOLED|POOLED|JNDI]”）\n\n\n\n\n\n\n\n\n\nUNPOOLED\n这个数据源的实现会每次请求时打开和关闭连接,会比较浪费服务器资源，对那些数据库连接可用性要求不高的简单应用程序来说，是一个很好的选择，性能比较依赖于数据库类型，这种类型的数据源需要以下配置：\n\ndriver –&gt;数据库驱动类名\nurl–&gt;数据库url地址\nusername–&gt;数据库登陆名\npassword–&gt;数据库登陆密码\ndefaultTransactionIsolationLevel –&gt; 默认的连接事务隔离级别。\ndefaultNetworkTimeout–&gt;数据库默认链接超时时间\ndriver.encoding=UTF8–&gt;设置数据库编码格式为UTF-8\n\n\n\n\n\n\n\n\n\n\nPOOLED\n这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。 这种处理方式很流行，能使并发 Web 应用快速响应请求。\n这种类型的数据源除了需要上面的配置之外还可以配置更多的属性\n详细可见官网\n\n\n\n\n\n\n\n\n\nJNDI\n这个数据源实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的数据源引用。这种数据源配置只需要两个属性\n\ninitial_context – 这个属性用来在 InitialContext 中寻找上下文（即，initialContext.lookup(initial_context)）。这是个可选属性，如果忽略，那么将会直接从 InitialContext 中寻找 data_source 属性。\ndata_source – 这是引用数据源实例位置的上下文路径。提供了 initial_context 配置时会在其返回的上下文中进行查找，没有提供时则直接在 InitialContext 中查找。\n\n2.6映射器 MyBatis 的行为已经由上述元素配置完了，我们现在就要来定义 SQL 映射语句了，我们需要告诉 MyBatis 到哪里去找到这些SQL语句。 在自动查找资源方面，Java 并没有提供一个很好的解决方案，所以最好的办法是直接告诉 MyBatis 到哪里去找映射文件\n&lt;!-- 使用相对于类路径的资源引用 --&gt;\n&lt;mappers&gt;\n  &lt;mapper resource&#x3D;&quot;org&#x2F;mybatis&#x2F;builder&#x2F;AuthorMapper.xml&quot;&#x2F;&gt;\n  &lt;mapper resource&#x3D;&quot;org&#x2F;mybatis&#x2F;builder&#x2F;BlogMapper.xml&quot;&#x2F;&gt;\n  &lt;mapper resource&#x3D;&quot;org&#x2F;mybatis&#x2F;builder&#x2F;PostMapper.xml&quot;&#x2F;&gt;\n&lt;&#x2F;mappers&gt;\n\n因为我的mapper.xml文件通常放在resources文件目录下\n所以使用这种注册方式比较多\n当然如果你把mapper.xml文件放入了src下的java目录下也可以使用这两种方式\n&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;\n&lt;mappers&gt;\n  &lt;mapper class&#x3D;&quot;org.mybatis.builder.AuthorMapper&quot;&#x2F;&gt;\n  &lt;mapper class&#x3D;&quot;org.mybatis.builder.BlogMapper&quot;&#x2F;&gt;\n  &lt;mapper class&#x3D;&quot;org.mybatis.builder.PostMapper&quot;&#x2F;&gt;\n&lt;&#x2F;mappers&gt;\n\n&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;\n&lt;mappers&gt;\n  &lt;package name&#x3D;&quot;org.mybatis.builder&quot;&#x2F;&gt;\n&lt;&#x2F;mappers&gt;\n\n注意：使用这两种方法必须把Mapper接口和Mapper.xml文件放在同一目录下\n","slug":"Mybatis配置详解","date":"2022-02-10T11:40:11.000Z","categories_index":"Mybatis","tags_index":"Mybatis","author_index":"zniceya"},{"id":"a9afe666d8181b7b8b74143880e7533b","title":"工厂方法模式","content":"\n\n\n\n\n\n\n\n\n沉淀、分享、成长，让自己和他人都能有所收获！\n前言好看的代码千篇一律，恶心的程序升职加薪。\n\n\n\n\n\n\n\n\n\n几乎是程序员就都知道或者了解设计模式，但大部分小伙伴写代码总是习惯于一把梭。无论多少业务逻辑就一个类几千行，这样的开发也可以归纳为三步；定义属性、创建方法、调用展示，Done！只不过开发一时爽，重构火葬场。\n\n\n\n\n\n\n\n\n\n好的代码不只为了完成现有功能，也会考虑后续扩展。在结构设计上松耦合易读易扩展，在领域实现上高内聚不对外暴漏实现细节不被外部干扰。而这就有点像家里三居(MVC)室、四居(DDD)室的装修，你不会允许几十万的房子把走线水管裸漏在外面，也不会允许把马桶放到厨房，炉灶安装到卫生间。\n开发环境\njdk1.8\nIDEA+Maven\n\n工厂方法模式介绍\n\n工厂方法模式，图片来自 refactoringguru.cn\n\n工厂模式又称工厂方法模式，是一种创建型设计模式，其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。\n这种设计模式也是 Java 开发中最常见的一种模式，它的主要意图是定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。\n简单说就是为了提供代码结构的扩展性，屏蔽每一个功能类中的具体实现逻辑。让外部可以更加简单的只是知道调用即可，同时，这也是去掉众多ifelse的方式。当然这可能也有一些缺点，比如需要实现的类非常多，如何去维护，怎样减低开发成本。但这些问题都可以在后续的设计模式结合使用中，逐步降低\nexampleif…else…直接上代码\nif (val &#x3D;&#x3D; 1)&#123;\n    A a &#x3D; new A();\n    a.setA(1);\n    &#x2F;&#x2F; do something\n    log.info(&quot;执行A操作:&#123;&#125;&quot;,a);\n&#125;else if (val &#x3D;&#x3D; 2)&#123;\n    B b &#x3D; new B();\n    b.setB(2);\n    b.setBStr(&quot;BBBB&quot;);\n    &#x2F;&#x2F; do something\n    log.info(&quot;执行B操作:&#123;&#125;&quot;,b);\n&#125;else if (val &#x3D;&#x3D; 3)&#123;\n    C c &#x3D; new C();\n    c.setC(true);\n    &#x2F;&#x2F; do something\n    log.info(&quot;执行C操作:&#123;&#125;&quot;,c);\n&#125;\n\n\n如上就是使用 ifelse 非常直接的实现出来业务需求的一坨代码，如果仅从业务角度看，研发如期甚至提前实现了功能。\n那这样的代码目前来看并不会有什么问题，但如果在经过几次的迭代和拓展，接手这段代码的研发将十分痛苦。重构成本高需要理清之前每一个接口的使用，测试回归验证时间长，需要全部验证一次。这也就是很多人并不愿意接手别人的代码，如果接手了又被压榨开发时间。那么可想而知这样的 ifelse 还会继续增加。\n\nfactory接下来使用工厂方法模式来进行代码优化，也算是一次很小的重构。整理重构会你会发现代码结构清晰了、也具备了下次新增业务需求的扩展性。但在实际使用中还会对此进行完善，目前的只是抽离出最核心的部分体现到你面前，方便学习\n\n\n\n\n\n\n\n\n\n 定义接口\npublic interface IWord &#123;\n\n    void sayHello(int id, String name, Map&lt;String,Object&gt; extMap);\n\n&#125;\n\n\n\n\n\n\n\n\n\n\n实现接口\n@Slf4j\npublic class FactoryImpA implements IWord &#123;\n\n    @Override\n    public void sayHello(int id, String name, Map&lt;String, Object&gt; extMap) &#123;\n        log.info(&quot;id:&#123;&#125;,name:&#123;&#125;,map:&#123;&#125;&quot;,id,name,extMap);\n&#x2F;&#x2F;        Object something &#x3D; extMap.get(&quot;something&quot;);\n&#x2F;&#x2F;        something.doSomething\n    &#125;\n&#125;\n\n实现多个对应多个业务\n\n从上面可以看到每一种实现都包括在自己的类中，新增、修改或者删除都不会影响其他功能的测试，降低回归测试的可能。\n后续在新增的只需要按照此结构进行填充即可，非常易于维护和扩展。\n在统一了入参以及出参后，调用方不在需要关心内部逻辑，按照统一的方式即可处理\n\n\n\n\n\n\n\n\n\n\n创建工厂\npublic class WordFactory &#123;\n\n    public IWord getWordByVal(Integer val)&#123;\n        if (val &#x3D;&#x3D; null) return null;\n        if (val &#x3D;&#x3D; 1) return new FactoryImpA();\n&#x2F;&#x2F;        if (val &#x3D;&#x3D; 2) return .....\n        throw new RuntimeException(&quot;没有合适类型!&quot;);\n    &#125;\n&#125;\n\n\n\n这里我们定义了一个工厂类，在里面按照类型实现各种服务。可以非常干净整洁的处理你的代码，后续新增的在这里扩展即可。如果你不喜欢if判断，也可以使用switch或者map配置结构，会让代码更加干净。\n另外很多代码检查软件和编码要求，不喜欢if语句后面不写扩展，这里是为了更加干净的向你体现逻辑。在实际的业务编码中可以添加括号\n\n\n\n\n\n\n\n\n\n\n测试验证\nprivate void factoryTest(int val)&#123;\n    IWord wordByVal &#x3D; new WordFactory().getWordByVal(val);\n    wordByVal.sayHello(1,&quot;张三&quot;,new HashMap&lt;&gt;());\n&#125;\n\n\n\n总结\n从上到下的优化来看，工厂方法模式并不复杂，甚至这样的开发结构在你有所理解后，会发现更加简单了。\n那么这样的开发的好处知道后，也可以总结出来它的优点；避免创建者与具体的产品逻辑耦合、满足单一职责，每一个业务逻辑实现都在所属自己的类中完成、满足开闭原则，无需更改使用调用方就可以在程序中引入新的产品类型。但这样也会带来一些问题，比如有非常多的奖品类型，那么实现的子类会极速扩张。因此也需要使用其他的模式进行优化，这些在后续的设计模式中会逐步涉及到。\n从案例入手看设计模式往往要比看理论学的更加容易，因为案例是缩短理论到上手的最佳方式，如果你已经有所收获，一定要去尝试实操。\n\n","slug":"工厂方法模式","date":"2022-02-09T13:10:56.000Z","categories_index":"设计模式","tags_index":"工厂方法模式","author_index":"zniceya"},{"id":"08f5f5d9db8ab1e437781b3952ec2b51","title":"Mybatis基础入门","content":"1、Mybatis入门1.1导入依赖&lt;dependency&gt;\n    &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;3.5.6&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n导入依赖之后我们可以先按照官网所示先做一个小的demo\n1.2 编写配置文件\n第一步要使用Mybatis自然是需要Mybatis的配置文件了\n\n我们在src下的resources目录下新建一个Mybatis-config.xml文件\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE configuration\n  PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;\n  &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;\n&lt;configuration&gt;\n  \n&lt;&#x2F;configuration&gt;\n\nxml文件里面需要Mybatis的约束，从官网上拿下来就可以了\n大家都知道与数据库连接是需要一个Connection的，当然现在我们使用Mybatis仍然是需要的，\n当然在Mybatis里面它为我们做了封装\n我们只需要一个叫SqlSession的对象就可以了\n但是我们知道要连接数据库则是需要数据源的\n我们可以配置在上面的Mybatis-config.xml文件中\n&lt;environments default&#x3D;&quot;development&quot;&gt;\n        &lt;environment id&#x3D;&quot;development&quot;&gt;\n            &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt;\n            &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;\n                &lt;!--value&#x3D;&quot;$&#123;driver&#125;&quot;这种取值方式必须要读取properties文件--&gt;\n                &lt;!--我们可以通过在上面添加&lt;properties resource&#x3D;&quot;database.properties&quot;&#x2F;&gt;来读取properties文件--&gt;\n                &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;$&#123;driver&#125;&quot;&#x2F;&gt;\n                &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;url&#125;&quot;&#x2F;&gt;\n                &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;username&#125;&quot;&#x2F;&gt;\n                &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;password&#125;&quot;&#x2F;&gt;\n            &lt;&#x2F;dataSource&gt;\n        &lt;&#x2F;environment&gt;\n    &lt;&#x2F;environments&gt;\n\n这里也附上database.properties文件\ndriver&#x3D;com.mysql.jdbc.Driver\nurl&#x3D;jdbc:mysql:&#x2F;&#x2F;xxxx:3306&#x2F;mybatis?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8&amp;useSSL&#x3D;false\nusername&#x3D;root\npassword&#x3D;123456\n\n而我们需要知道的则是如何来拿到SqlSession对象并使用\n1.3编写MybatisUtils工具类\n如何拿到SqlSession并使用\n\n我们可以写一个工具类专门用于获取SqlSession对象\n首先我们通过看官网得知要使用SqlSession则必须有一个SqlSessionFactory对象来获取  \n通过看官网我们可以得知SqlSessionFactory对象则是由SqlSessionFactoryBuilder来获取的\nMybatisUtils文件放在下面\npublic class MyBatisUtils &#123;\n    private static SqlSessionFactory sqlSessionFactory;\n\n    static &#123;\n        InputStream inputStream &#x3D; null;\n        try &#123;\n            String resource &#x3D; &quot;Mybatis-config.xml&quot;;\n            inputStream &#x3D; Resources.getResourceAsStream(resource);\n            sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n\n    public static SqlSession getSqlSession()&#123;\n        return sqlSessionFactory.openSession();\n    &#125;\n&#125;\n\n到这里为止我们已经可以拿到数据库链接对象了\n下面我们实现一个小小的查询功能\n1.4实现查询功能首先我们遵循MVC三层架构模式\n建立以下几个包\n\n并提前把数据库字段映射成实体类（pojo）\n我们需要建一个mapper（dao）包，在mybatis项目中我习惯使用mapper\n然后在mapper包下面新建一个UserMapper接口\npublic interface UserMapper &#123;\n&#x2F;&#x2F;    获取所有用户\n    List&lt;User&gt; getUserList();\n&#125;\n\n\n按照我们以前的javaweb项目我们需要再建立一个UserMapper的实现类来实现它里面的方法\n而我们现在使用了Mybatis则不再需要实现类但我们需要一个UserMapper.xml来映射我们的UserMapper接口\n一般我们会把UserMapper.xml文件放在resources目录下\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;\n        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace&#x3D;&quot;fun.nicely.mapper.UserMapper&quot;&gt;\n\n    \n    \n&lt;&#x2F;mapper&gt;\n\n注意在这里我们一定要指明这个mapper文件映射的是哪个接口也就是：namespace 命名空间\n然后我们需要在这个mapper文件中写上SQL语句\n&lt;select id&#x3D;&quot;getUserList&quot; resultType&#x3D;&quot;fun.nicely.pojo.User&quot;&gt;\n        select * from user\n&lt;&#x2F;select&gt;\n\n注意id一定要和接口里面的方法名一样，mybatis就是通过id来映射的方法\n而resultType则是接口里面的方法要返回的数据类型\n最后\n最后我们要把UserMapper.xml文件注册到Mybatis-config.xml文件中\n我们在Mybatis-config.xml文件最后加上\n&lt;mappers&gt;\n        &lt;mapper resource&#x3D;&quot;UserMapper.xml&quot;&#x2F;&gt;\n&lt;&#x2F;mappers&gt;\n\n1.5测试我们写一个方法测试一下\n @Test\npublic void test() &#123;\n    SqlSession sqlSession &#x3D; null;\n    try &#123;\n        sqlSession &#x3D; MyBatisUtils.getSqlSession();\n        UserMapper mapper &#x3D; sqlSession.getMapper(UserMapper.class);\n        List&lt;User2&gt; userList &#x3D; mapper.getUserList();\n        for (User2 user : userList) &#123;\n            System.out.println(user);\n        &#125;\n    &#125;catch (Exception e)&#123;\n        e.printStackTrace();\n    &#125;finally &#123;\n        if (sqlSession !&#x3D; null) &#123;\n            sqlSession.close();\n        &#125;\n    &#125;\n&#125;\n\n测试结果\n","slug":"Mybatis基础入门","date":"2022-02-09T07:30:11.000Z","categories_index":"Mybatis","tags_index":"Mybatis","author_index":"zniceya"},{"id":"95396110157e32674f9e9b0cbf309339","title":"给网站加上鼠标点击烟花效果","content":"给网站加上鼠标点击烟花效果\n\n\n\n\n\n\n\n\n效果如图\n\n\n\n\n\n\n\n\n\n\n具体实现\nclass Circle &#123;\n    constructor(&#123; origin, speed, color, angle, context &#125;) &#123;\n        this.origin &#x3D; origin\n        this.position &#x3D; &#123; ...this.origin &#125;\n        this.color &#x3D; color\n        this.speed &#x3D; speed\n        this.angle &#x3D; angle\n        this.context &#x3D; context\n        this.renderCount &#x3D; 0\n    &#125;\n\n    draw() &#123;\n        this.context.fillStyle &#x3D; this.color\n        this.context.beginPath()\n        this.context.arc(this.position.x, this.position.y, 2, 0, Math.PI * 2)\n        this.context.fill()\n    &#125;\n\n    move() &#123;\n        this.position.x &#x3D; (Math.sin(this.angle) * this.speed) + this.position.x\n        this.position.y &#x3D; (Math.cos(this.angle) * this.speed) + this.position.y + (this.renderCount * 0.3)\n        this.renderCount++\n    &#125;\n&#125;\n\nclass Boom &#123;\n    constructor (&#123; origin, context, circleCount &#x3D; 10, area &#125;) &#123;\n        this.origin &#x3D; origin\n        this.context &#x3D; context\n        this.circleCount &#x3D; circleCount\n        this.area &#x3D; area\n        this.stop &#x3D; false\n        this.circles &#x3D; []\n    &#125;\n\n    randomArray(range) &#123;\n        const length &#x3D; range.length\n        const randomIndex &#x3D; Math.floor(length * Math.random())\n        return range[randomIndex]\n    &#125;\n\n    randomColor() &#123;\n        const range &#x3D; [&#39;8&#39;, &#39;9&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;]\n        return &#39;#&#39; + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) + this.randomArray(range)\n    &#125;\n\n    randomRange(start, end) &#123;\n        return (end - start) * Math.random() + start\n    &#125;\n\n    init() &#123;\n        for(let i &#x3D; 0; i &lt; this.circleCount; i++) &#123;\n            const circle &#x3D; new Circle(&#123;\n                context: this.context,\n                origin: this.origin,\n                color: this.randomColor(),\n                angle: this.randomRange(Math.PI - 1, Math.PI + 1),\n                speed: this.randomRange(1, 6)\n            &#125;)\n            this.circles.push(circle)\n        &#125;\n    &#125;\n\n    move() &#123;\n        this.circles.forEach((circle, index) &#x3D;&gt; &#123;\n            if (circle.position.x &gt; this.area.width || circle.position.y &gt; this.area.height) &#123;\n                return this.circles.splice(index, 1)\n            &#125;\n            circle.move()\n        &#125;)\n        if (this.circles.length &#x3D;&#x3D; 0) &#123;\n            this.stop &#x3D; true\n        &#125;\n    &#125;\n\n    draw() &#123;\n        this.circles.forEach(circle &#x3D;&gt; circle.draw())\n    &#125;\n&#125;\n\nclass CursorSpecialEffects &#123;\n    constructor() &#123;\n        this.computerCanvas &#x3D; document.createElement(&#39;canvas&#39;)\n        this.renderCanvas &#x3D; document.createElement(&#39;canvas&#39;)\n\n        this.computerContext &#x3D; this.computerCanvas.getContext(&#39;2d&#39;)\n        this.renderContext &#x3D; this.renderCanvas.getContext(&#39;2d&#39;)\n\n        this.globalWidth &#x3D; window.innerWidth\n        this.globalHeight &#x3D; window.innerHeight\n\n        this.booms &#x3D; []\n        this.running &#x3D; false\n    &#125;\n\n    handleMouseDown(e) &#123;\n        const boom &#x3D; new Boom(&#123;\n            origin: &#123; x: e.clientX, y: e.clientY &#125;,\n            context: this.computerContext,\n            area: &#123;\n                width: this.globalWidth,\n                height: this.globalHeight\n            &#125;\n        &#125;)\n        boom.init()\n        this.booms.push(boom)\n        this.running || this.run()\n    &#125;\n\n    handlePageHide() &#123;\n        this.booms &#x3D; []\n        this.running &#x3D; false\n    &#125;\n\n    init() &#123;\n        const style &#x3D; this.renderCanvas.style\n        style.position &#x3D; &#39;fixed&#39;\n        style.top &#x3D; style.left &#x3D; 0\n        style.zIndex &#x3D; &#39;999999999999999999999999999999999999999999&#39;\n        style.pointerEvents &#x3D; &#39;none&#39;\n\n        style.width &#x3D; this.renderCanvas.width &#x3D; this.computerCanvas.width &#x3D; this.globalWidth\n        style.height &#x3D; this.renderCanvas.height &#x3D; this.computerCanvas.height &#x3D; this.globalHeight\n\n        document.body.append(this.renderCanvas)\n\n        window.addEventListener(&#39;mousedown&#39;, this.handleMouseDown.bind(this))\n        window.addEventListener(&#39;pagehide&#39;, this.handlePageHide.bind(this))\n    &#125;\n\n    run() &#123;\n        this.running &#x3D; true\n        if (this.booms.length &#x3D;&#x3D; 0) &#123;\n            return this.running &#x3D; false\n        &#125;\n\n        requestAnimationFrame(this.run.bind(this))\n\n        this.computerContext.clearRect(0, 0, this.globalWidth, this.globalHeight)\n        this.renderContext.clearRect(0, 0, this.globalWidth, this.globalHeight)\n\n        this.booms.forEach((boom, index) &#x3D;&gt; &#123;\n            if (boom.stop) &#123;\n                return this.booms.splice(index, 1)\n            &#125;\n            boom.move()\n            boom.draw()\n        &#125;)\n        this.renderContext.drawImage(this.computerCanvas, 0, 0, this.globalWidth, this.globalHeight)\n    &#125;\n&#125;\n\nconst cursorSpecialEffects &#x3D; new CursorSpecialEffects()\ncursorSpecialEffects.init()\n","slug":"给网站加上鼠标点击烟花效果","date":"2022-02-05T09:22:11.000Z","categories_index":"other","tags_index":"other","author_index":"zniceya"},{"id":"f4f86e9970dc96526d88d830c56237c7","title":"Docker 容器使用","content":"Docker 容器使用Docker 客户端docker 客户端非常简单 ,我们可以直接输入 docker 命令来查看到 Docker 客户端的所有命令选项。\nroot@VM-16-2-ubuntu:# docker\n\n可以通过命令 docker command –help 更深入的了解指定的 Docker 命令使用方法。\n例如我们要查看 docker stats 指令的具体使用方法：\nroot@VM-16-2-ubuntu:# docker stats --help\n\n容器使用获取镜像如果我们本地没有 ubuntu 镜像，我们可以使用 docker pull 命令来载入 ubuntu 镜像：\n$ docker pull ubuntu\n启动容器以下命令使用 ubuntu 镜像启动一个容器，参数为以命令行模式进入该容器：\n$ docker run -it ubuntu &#x2F;bin&#x2F;bash\n\n参数说明：\n\n-i: 交互式操作。\n-t: 终端。\nubuntu: ubuntu 镜像。\n/bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。\n\n要退出终端，直接输入 exit:\nroot@ed09e4490c57:&#x2F;# exit\n\n启动已停止运行的容器查看所有的容器命令如下：\n$ docker ps -a\n\n\n使用 docker start 启动一个已停止的容器：\n$ docker start b750bbbcfd88 \n\n后台运行在大部分的场景下，我们希望 docker 的服务是在后台运行的，我们可以过 -d 指定容器的运行模式。\n$ docker run -itd --name ubuntu-test ubuntu &#x2F;bin&#x2F;bash\n\n注：加了 -d 参数默认不会进入容器，想要进入容器需要使用指令 docker exec（下面会介绍到）。\n停止一个容器停止容器的命令如下：\n$ docker stop &lt;容器 ID&gt;\n\n停止的容器可以通过 docker restart 重启：\n$ docker restart &lt;容器 ID&gt;\n\n进入容器在使用 -d 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入：\n\ndocker attach\ndocker exec：推荐大家使用 docker exec 命令，因为此退出容器终端，不会导致容器的停止。\n\n\n\n\n\n\n\n\n\n\nattach 命令\n下面演示了使用 docker attach 命令。\n$ docker attach 1e560fca3906 \n\n注意： 如果从这个容器退出，会导致容器的停止。\n\n\n\n\n\n\n\n\n\nexec 命令\n下面演示了使用 docker exec 命令。\ndocker exec -it 243c32535da7 &#x2F;bin&#x2F;bash\n\n注意： 如果从这个容器退出，容器不会停止，这就是为什么推荐大家使用 docker exec 的原因。\n更多参数说明请使用 docker exec –help 命令查看。\n导出和导入容器导出容器如果要导出本地某个容器，可以使用 docker export 命令。\n$ docker export 1e560fca3906 &gt; ubuntu.tar\n导出容器 1e560fca3906 快照到本地文件 ubuntu.tar。\n\n这样将导出容器快照到本地文件。\n导入容器快照可以使用 docker import 从容器快照文件中再导入为镜像，以下实例将快照文件 ubuntu.tar 导入到镜像 test/ubuntu:v1:\n$ cat docker&#x2F;ubuntu.tar | docker import - test&#x2F;ubuntu:v1\n此外，也可以通过指定 URL 或者某个目录来导入，例如：\n$ docker import http:&#x2F;&#x2F;example.com&#x2F;exampleimage.tgz example&#x2F;imagerepo\n删除容器删除容器使用 docker rm 命令：\n$ docker rm -f 1e560fca3906\n\n下面的命令可以清理掉所有处于终止状态的容器。\n$ docker container prune\n","slug":"Docker容器使用","date":"2022-01-21T09:22:11.000Z","categories_index":"Docker","tags_index":"Docker","author_index":"zniceya"}]